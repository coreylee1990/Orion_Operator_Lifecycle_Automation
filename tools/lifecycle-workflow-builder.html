<!DOCTYPE html>
<html lang="en">
<head>
        <!-- Bootstrap CSS -->
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Operator Lifecycle Workflow Builder</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #e2e6f0 0%, #e0e1e3 50%, #dedede 100%);
            min-height: 100vh;
            padding: 20px;
            color: #e2e8f0;
        }
/* Accordion custom style */
.accordion-body {
    background: #5b657a !important;
    border-radius: 0 0 12px 12px;
    color: white;
}

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 40px;
            padding: 30px;
            background: rgba(15, 23, 42, 0.6);
            border-radius: 16px;
            border: 1px solid rgba(148, 163, 184, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        h1 {
            font-size: 2.5rem;
            background: linear-gradient(135deg, #60a5fa, #a78bfa);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #94a3b8;
            font-size: 1.1rem;
        }

        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .btn-primary {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(59, 130, 246, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
        }

        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(16, 185, 129, 0.4);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
        }

        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(239, 68, 68, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #6b7280, #4b5563);
            color: white;
        }

        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(107, 114, 128, 0.4);
        }

        .btn-toggle {
            background: linear-gradient(135deg, #8b5cf6, #7c3aed);
            color: white;
        }

        .btn-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(139, 92, 246, 0.4);
        }

        .btn-toggle.active {
            background: linear-gradient(135deg, #10b981, #059669);
        }

        select.division-select {
            padding: 12px 16px;
            border: 2px solid rgba(148, 163, 184, 0.2);
            border-radius: 8px;
            font-size: 1rem;
            background: rgba(30, 41, 59, 0.6);
            color: #e2e8f0;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 200px;
        }

        select.division-select:hover {
            border-color: rgba(96, 165, 250, 0.5);
        }

        select.division-select:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .editor-container {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .cert-pool {
            background: rgba(15, 23, 42, 0.6);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(148, 163, 184, 0.1);
            max-height: 800px;
            overflow-y: auto;
        }

        .cert-pool h3 {
            color: #60a5fa;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }

        .cert-badge {
            background: linear-gradient(135deg, #1e293b, #334155);
            padding: 10px 14px;
            border-radius: 8px;
            margin-bottom: 8px;
            cursor: move;
            border: 2px solid rgba(148, 163, 184, 0.2);
            transition: all 0.2s ease;
            font-size: 0.9rem;
        }

        .cert-badge:hover {
            border-color: #60a5fa;
            transform: translateX(5px);
            box-shadow: 0 4px 12px rgba(96, 165, 250, 0.3);
        }

        .cert-badge-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .delete-cert-type-btn {
            background: rgba(239, 68, 68, 0.2);
            border: none;
            color: #fca5a5;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            transition: all 0.2s ease;
            margin-left: 8px;
        }

        .delete-cert-type-btn:hover {
            background: #ef4444;
            color: white;
        }

        .cert-badge.dragging {
            opacity: 0.5;
            transform: scale(0.95);
        }

        .requirements-grid {
            display: grid;
            gap: 15px;
        }

        .status-requirement-card {
            background: rgba(15, 23, 42, 0.6);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(148, 163, 184, 0.1);
            cursor: grab;
            transition: all 0.3s ease;
            position: relative;
        }

        .status-requirement-card.dragging-status {
            opacity: 0.5;
            transform: scale(0.98);
            cursor: grabbing;
        }

        .status-requirement-card.drag-over-status {
            border-color: #a78bfa;
            background: rgba(167, 139, 250, 0.1);
            transform: translateY(-4px);
        }

        .status-requirement-card h3 {
            color: #60a5fa;
            margin-bottom: 15px;
            font-size: 1.1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .status-order-badge {
            background: rgba(167, 139, 250, 0.2);
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.8rem;
            color: #a78bfa;
            margin-right: 8px;
            font-weight: bold;
        }

        .drag-handle {
            cursor: grab;
            font-size: 1.2rem;
            margin-right: 8px;
            opacity: 0.6;
            transition: opacity 0.2s;
        }

        .status-requirement-card:hover .drag-handle {
            opacity: 1;
        }

        .cert-count-badge {
            background: rgba(96, 165, 250, 0.2);
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.85rem;
            color: #60a5fa;
        }

        .drop-zone {
            min-height: 100px;
            border: 2px dashed rgba(148, 163, 184, 0.3);
            border-radius: 8px;
            padding: 15px;
            transition: all 0.3s ease;
        }

        .drop-zone.drag-over {
            border-color: #10b981;
            background: rgba(16, 185, 129, 0.1);
            transform: scale(1.02);
        }

        .assigned-cert {
            background: linear-gradient(135deg, #1e40af, #1e3a8a);
            padding: 8px 12px;
            border-radius: 6px;
            margin-bottom: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
        }

        .remove-cert-btn {
            background: rgba(239, 68, 68, 0.3);
            border: none;
            color: #fca5a5;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.85rem;
            transition: all 0.2s ease;
        }

        .remove-cert-btn:hover {
            background: #ef4444;
            color: white;
        }

        .save-panel {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: rgba(15, 23, 42, 0.95);
            padding: 20px;
            border-radius: 12px;
            border: 2px solid rgba(96, 165, 250, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            display: none;
            z-index: 1000;
        }

        .save-panel.show {
            display: block;
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from {
                transform: translateY(100px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .change-summary {
            color: #94a3b8;
            font-size: 0.9rem;
            margin-bottom: 15px;
        }

        .change-summary strong {
            color: #60a5fa;
        }

        .workflow-canvas {
            background: rgba(15, 23, 42, 0.4);
            border-radius: 16px;
            padding: 40px;
            min-height: 600px;
            border: 2px dashed rgba(148, 163, 184, 0.2);
            position: relative;
        }

        .workflow-steps {
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow: visible;
        }

        .step-card {
            background: linear-gradient(135deg, rgba(30, 41, 59, 0.9), rgba(51, 65, 85, 0.9));
            border-radius: 12px;
            padding: 20px;
            border: 2px solid rgba(148, 163, 184, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            cursor: move;
            transition: all 0.3s ease;
            position: relative;
            z-index: 1;
            overflow: visible;
        }

        .step-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4);
            border-color: rgba(96, 165, 250, 0.5);
        }

        .step-card.dragging {
            opacity: 0.5;
            transform: scale(0.95);
        }

        .step-card.drag-over {
            border-color: #60a5fa;
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.2), rgba(37, 99, 235, 0.2));
        }

        .step-card.valid {
            border-left: 4px solid #10b981;
        }

        .step-card.invalid {
            border-left: 4px solid #ef4444;
        }

        .step-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .step-number {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 1.1rem;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
        }

        .step-info {
            flex: 1;
            margin-left: 15px;
        }

        .step-title {
            font-size: 1.3rem;
            font-weight: 700;
            color: #e2e8f0;
            margin-bottom: 5px;
        }

        .step-meta {
            display: flex;
            gap: 15px;
            font-size: 0.9rem;
            color: #94a3b8;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 12px;
            border-radius: 6px;
            font-weight: 600;
            font-size: 0.85rem;
        }

        .status-indicator.valid {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
        }

        .status-indicator.invalid {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .status-indicator.valid .status-dot {
            background: #10b981;
        }

        .status-indicator.invalid .status-dot {
            background: #ef4444;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .operators-dropdown {
            margin-top: 15px;
        }

        .dropdown-trigger {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: rgba(15, 23, 42, 0.6);
            border: 1px solid rgba(148, 163, 184, 0.2);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .dropdown-trigger:hover {
            background: rgba(15, 23, 42, 0.8);
            border-color: rgba(96, 165, 250, 0.5);
        }

        .dropdown-trigger .count {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-weight: 700;
            font-size: 0.9rem;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
        }

        .dropdown-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            margin-top: 10px;
        }

        .dropdown-content.open {
            max-height: 400px;
            overflow-y: auto;
        }

        .operator-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 16px;
            background: rgba(15, 23, 42, 0.4);
            border: 1px solid rgba(148, 163, 184, 0.1);
            border-radius: 6px;
            margin-bottom: 8px;
            transition: all 0.2s ease;
        }

        .operator-item:hover {
            background: rgba(15, 23, 42, 0.6);
            border-color: rgba(96, 165, 250, 0.3);
        }

        .operator-name {
            font-weight: 600;
            color: #e2e8f0;
        }

        .cert-status {
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .cert-status.complete {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
        }

        .cert-status.incomplete {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }

        .cert-details {
            margin-top: 15px;
            padding: 15px;
            background: rgba(15, 23, 42, 0.4);
            border-radius: 8px;
            border: 1px solid rgba(148, 163, 184, 0.1);
        }

        .cert-title {
            font-weight: 700;
            color: #e2e8f0;
            margin-bottom: 10px;
        }

        .cert-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .cert-badge {
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.85rem;
            font-weight: 600;
            background: rgba(59, 130, 246, 0.2);
            color: #60a5fa;
            border: 1px solid rgba(59, 130, 246, 0.3);
            cursor: move;
            position: relative;
            padding-right: 28px;
            transition: all 0.2s ease;
        }

        .cert-badge:hover {
            background: rgba(59, 130, 246, 0.3);
            transform: translateY(-2px);
        }

        .cert-badge.dragging-cert {
            opacity: 0.5;
        }

        .cert-badge .remove-cert {
            position: absolute;
            right: 6px;
            top: 50%;
            transform: translateY(-50%);
            cursor: pointer;
            color: #ef4444;
            font-weight: 700;
            padding: 0 4px;
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }

        .cert-badge .remove-cert:hover {
            opacity: 1;
        }

        .add-cert-section {
            margin-top: 15px;
            padding: 15px;
            background: rgba(15, 23, 42, 0.4);
            border-radius: 8px;
            border: 1px solid rgba(148, 163, 184, 0.1);
            position: relative;
            overflow: visible;
            z-index: 200;
        }

        .add-cert-input {
            display: flex;
            gap: 10px;
            align-items: center;
            position: relative;
            overflow: visible;
            z-index: 201;
        }

        .add-cert-input-wrapper {
            flex: 1;
            position: relative;
            z-index: 202;
            overflow: visible;
        }

        .add-cert-input input {
            width: 100%;
            padding: 10px 15px;
            background: rgba(15, 23, 42, 0.6);
            border: 1px solid rgba(148, 163, 184, 0.3);
            border-radius: 6px;
            color: #e2e8f0;
            font-size: 0.9rem;
        }

        .add-cert-input input:focus {
            outline: none;
            border-color: #60a5fa;
        }

        .autocomplete-dropdown {
            position: relative;
            max-height: 300px;
            overflow-y: auto;
            background: rgba(15, 23, 42, 0.98);
            border: 1px solid rgba(96, 165, 250, 0.5);
            border-radius: 6px;
            margin-top: 5px;
            z-index: 9999;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8), 0 0 0 1px rgba(96, 165, 250, 0.3);
            display: none;
            backdrop-filter: blur(10px);
        }

        .autocomplete-dropdown.active {
            display: block;
        }

        .autocomplete-item {
            padding: 10px 15px;
            cursor: pointer;
            color: #e2e8f0;
            transition: all 0.2s ease;
            border-bottom: 1px solid rgba(148, 163, 184, 0.1);
        }

        .autocomplete-item:last-child {
            border-bottom: none;
        }

        .autocomplete-item:hover {
            background: rgba(59, 130, 246, 0.2);
        }

        .autocomplete-item.highlighted {
            background: rgba(59, 130, 246, 0.3);
        }

        .autocomplete-no-results {
            padding: 12px;
            color: #94a3b8;
            font-size: 13px;
            font-style: italic;
        }

        .autocomplete-item .cert-name {
            font-weight: 600;
        }

        /* Add Status Modal Styles */
        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: #94a3b8;
            font-size: 0.9rem;
        }

        .form-group select,
        .form-group input {
            width: 100%;
            padding: 12px;
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 8px;
            color: #e2e8f0;
            font-size: 1rem;
        }

        .form-group select:focus,
        .form-group input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        .status-option-deleted {
            color: #ef4444;
            font-style: italic;
        }
        
        /* Control Center Features */
        .control-panel {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            border: 1px solid #334155;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .control-panel h3 {
            margin: 0 0 15px 0;
            color: #e2e8f0;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .search-bar {
            position: relative;
            margin-bottom: 15px;
        }

        .search-input {
            width: 100%;
            padding: 12px 40px 12px 40px;
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 8px;
            color: #e2e8f0;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .search-input:focus {
            outline: none;
            border-color: #3b82f6;
            background: #0f172a;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .search-icon {
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: #64748b;
            font-size: 16px;
        }

        .clear-search {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: #64748b;
            cursor: pointer;
            font-size: 18px;
            padding: 4px 8px;
            transition: color 0.2s;
        }

        .clear-search:hover {
            color: #e2e8f0;
        }

        .filter-options {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .filter-btn {
            padding: 8px 16px;
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 6px;
            color: #94a3b8;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        .filter-btn:hover {
            background: #334155;
            color: #e2e8f0;
        }

        .filter-btn.active {
            background: #3b82f6;
            border-color: #3b82f6;
            color: white;
        }

        .bulk-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .bulk-btn {
            padding: 10px 18px;
            background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%);
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .bulk-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.4);
        }

        .bulk-btn.danger {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
        }

        .bulk-btn.danger:hover {
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.4);
        }

        .bulk-btn.success {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        }

        .bulk-btn.success:hover {
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
        }

        .details-panel {
            position: fixed;
            right: -400px;
            top: 0;
            width: 400px;
            height: 100vh;
            background: #0f172a;
            border-left: 1px solid #334155;
            box-shadow: -4px 0 20px rgba(0, 0, 0, 0.3);
            transition: right 0.3s ease;
            z-index: 1000;
            overflow-y: auto;
        }

        .details-panel.open {
            right: 0;
        }

        .details-header {
            padding: 20px;
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            border-bottom: 1px solid #334155;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .details-header h3 {
            margin: 0 0 5px 0;
            color: #e2e8f0;
            font-size: 1.2rem;
        }

        .details-subtitle {
            color: #94a3b8;
            font-size: 0.9rem;
        }

        .close-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            color: #94a3b8;
            cursor: pointer;
            font-size: 24px;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: color 0.2s;
        }

        .close-panel:hover {
            color: #e2e8f0;
        }

        .details-content {
            padding: 20px;
        }

        .details-section {
            margin-bottom: 25px;
        }

        .details-section h4 {
            color: #e2e8f0;
            font-size: 1rem;
            margin: 0 0 12px 0;
            padding-bottom: 8px;
            border-bottom: 1px solid #334155;
        }

        .operator-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .operator-item {
            padding: 10px;
            background: #1e293b;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .operator-name {
            color: #e2e8f0;
            font-weight: 500;
        }

        .operator-status-badge {
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
        }

        .operator-status-badge.has-cert {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
        }

        .operator-status-badge.missing-cert {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }

        .operator-status-badge.expired {
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
        }

        .highlight {
            background: rgba(251, 191, 36, 0.3);
            padding: 2px 4px;
            border-radius: 3px;
        }

        .export-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .export-modal.open {
            display: flex;
        }

        .export-content {
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 12px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
        }

        .export-content h3 {
            margin: 0 0 20px 0;
            color: #e2e8f0;
        }

        .export-options {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 20px;
        }

        .export-option {
            padding: 15px;
            background: #0f172a;
            border: 1px solid #334155;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .export-option:hover {
            background: #1e293b;
            border-color: #3b82f6;
        }

        .export-option h4 {
            margin: 0 0 5px 0;
            color: #e2e8f0;
            font-size: 1rem;
        }

        .export-option p {
            margin: 0;
            color: #94a3b8;
            font-size: 0.9rem;
        }

        /* Operator Profile Modal */
        .operator-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 10000;
            align-items: center;
            justify-content: center;
        }

        .operator-modal.open {
            display: flex;
        }

        .operator-modal-content {
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            border: 1px solid #334155;
            border-radius: 16px;
            padding: 0;
            max-width: 700px;
            width: 90%;
            max-height: 85vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        .operator-modal-header {
            padding: 25px 30px;
            background: linear-gradient(135deg, #334155 0%, #1e293b 100%);
            border-bottom: 1px solid #475569;
            position: relative;
        }

        .operator-modal-header h2 {
            margin: 0 0 8px 0;
            color: #e2e8f0;
            font-size: 1.5rem;
        }

        .operator-modal-subtitle {
            color: #94a3b8;
            font-size: 0.9rem;
            margin: 0;
        }

        .close-operator-modal {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(51, 65, 85, 0.5);
            border: 1px solid #475569;
            color: #e2e8f0;
            cursor: pointer;
            font-size: 24px;
            padding: 8px 12px;
            border-radius: 8px;
            transition: all 0.2s;
            line-height: 1;
        }

        .close-operator-modal:hover {
            background: rgba(239, 68, 68, 0.3);
            border-color: #ef4444;
            color: #ef4444;
        }

        .operator-modal-body {
            padding: 25px 30px;
            overflow-y: auto;
        }

        .operator-info-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-bottom: 25px;
            padding: 20px;
            background: rgba(15, 23, 42, 0.5);
            border-radius: 12px;
            border: 1px solid #334155;
        }

        .operator-info-item {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .operator-info-label {
            color: #94a3b8;
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .operator-info-value {
            color: #e2e8f0;
            font-size: 1rem;
            font-weight: 500;
        }

        .certs-section-title {
            color: #e2e8f0;
            font-size: 1.2rem;
            font-weight: 600;
            margin: 0 0 15px 0;
            padding-bottom: 10px;
            border-bottom: 2px solid #334155;
        }

        .cert-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 12px;
            margin-bottom: 20px;
        }

        .cert-card {
            padding: 12px 15px;
            border-radius: 8px;
            border: 1px solid;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s;
        }

        .cert-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .cert-card.has-cert {
            background: rgba(16, 185, 129, 0.1);
            border-color: rgba(16, 185, 129, 0.3);
        }

        .cert-card.expired {
            background: rgba(251, 191, 36, 0.1);
            border-color: rgba(251, 191, 36, 0.3);
        }

        .cert-card.missing {
            background: rgba(239, 68, 68, 0.1);
            border-color: rgba(239, 68, 68, 0.3);
        }

        .cert-card-name {
            color: #e2e8f0;
            font-size: 0.9rem;
            font-weight: 500;
            flex: 1;
        }

        .cert-card-status {
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .cert-card.has-cert .cert-card-status {
            background: rgba(16, 185, 129, 0.2);
            color: #10b981;
        }

        .cert-card.expired .cert-card-status {
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
        }

        .cert-card.missing .cert-card-status {
            background: rgba(239, 68, 68, 0.2);
            color: #ef4444;
        }

        .cert-stats {
            display: flex;
            gap: 20px;
            padding: 15px;
            background: rgba(15, 23, 42, 0.5);
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .cert-stat {
            flex: 1;
            text-align: center;
        }

        .cert-stat-value {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .cert-stat-value.valid { color: #10b981; }
        .cert-stat-value.expired { color: #fbbf24; }
        .cert-stat-value.missing { color: #ef4444; }

        .cert-stat-label {
            color: #94a3b8;
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        /* Operator Progress Bar */
        .operator-progress {
            display: flex;
            height: 8px;
            background: rgba(239, 68, 68, 0.3);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 6px;
            border: 1px solid rgba(51, 65, 85, 0.3);
            flex: 1;
            max-width: 120px;
        }

        .operator-progress-segment {
            height: 100%;
            transition: width 0.3s ease;
        }

        .operator-progress-segment.valid {
            background: #10b981;
        }

        .operator-progress-segment.expired {
            background: #fbbf24;
        }

        .operator-progress-segment.missing {
            background: #ef4444;
        }

        .operator-item {
            padding: 10px 12px;
            background: rgba(15, 23, 42, 0.3);
            border-radius: 8px;
            border: 1px solid rgba(51, 65, 85, 0.5);
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .operator-item:hover {
            background: rgba(15, 23, 42, 0.5);
            border-color: rgba(99, 102, 241, 0.5);
            transform: translateX(4px);
        }

        .operator-name {
            flex: 1;
        }

        /* Operator Progress Bar */
        .operator-progress {
            display: flex;
            height: 6px;
            background: rgba(15, 23, 42, 0.5);
            border-radius: 3px;
            overflow: hidden;
            margin-top: 6px;
            border: 1px solid rgba(51, 65, 85, 0.5);
        }

        .operator-progress-segment {
            height: 100%;
            transition: width 0.3s ease;
        }

        .operator-progress-segment.valid {
            background: linear-gradient(90deg, #10b981, #059669);
        }

        .operator-progress-segment.expired {
            background: linear-gradient(90deg, #fbbf24, #f59e0b);
        }

        .operator-progress-segment.missing {
            background: linear-gradient(90deg, #ef4444, #dc2626);
        }

        .operator-cert-stats {
            display: flex;
            gap: 8px;
            margin-top: 4px;
            font-size: 0.75rem;
            color: #94a3b8;
        }

        .operator-cert-stat {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .operator-cert-stat-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .operator-cert-stat-dot.valid { background: #10b981; }
        .operator-cert-stat-dot.expired { background: #fbbf24; }
        .operator-cert-stat-dot.missing { background: #ef4444; }

        .operator-item {
            padding: 12px;
            background: rgba(15, 23, 42, 0.3);
            border-radius: 8px;
            border: 1px solid rgba(51, 65, 85, 0.5);
            transition: all 0.2s;
        }

        .operator-item:hover {
            background: rgba(15, 23, 42, 0.5);
            border-color: rgba(99, 102, 241, 0.5);
            transform: translateX(4px);
        }

        .autocomplete-item .cert-status-list {
            font-size: 0.75rem;
            color: #94a3b8;
            margin-top: 3px;
        }

        .autocomplete-no-results {
            padding: 10px 15px;
            color: #94a3b8;
            font-style: italic;
            text-align: center;
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 0.85rem;
        }

        .cert-list.drop-zone {
            min-height: 50px;
            border: 2px dashed rgba(96, 165, 250, 0.3);
            padding: 10px;
            border-radius: 6px;
        }

        .unsaved-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(245, 158, 11, 0.4);
            font-weight: 600;
            display: none;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .cert-list-editable {
            min-height: 40px;
        }

        .stats-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, rgba(30, 41, 59, 0.9), rgba(51, 65, 85, 0.9));
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(148, 163, 184, 0.2);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
        }

        .stat-value {
            font-size: 2.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, #60a5fa, #a78bfa);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 5px;
        }

        .stat-label {
            color: #94a3b8;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .legend {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-bottom: 30px;
            padding: 15px;
            background: rgba(15, 23, 42, 0.4);
            border-radius: 12px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }

        .legend-color.valid {
            background: #10b981;
        }

        .legend-color.invalid {
            background: #ef4444;
        }

        /* Scrollbar styling */
        .dropdown-content::-webkit-scrollbar {
            width: 8px;
        }

        .dropdown-content::-webkit-scrollbar-track {
            background: rgba(15, 23, 42, 0.4);
            border-radius: 4px;
        }

        .dropdown-content::-webkit-scrollbar-thumb {
            background: rgba(96, 165, 250, 0.5);
            border-radius: 4px;
        }

        .dropdown-content::-webkit-scrollbar-thumb:hover {
            background: rgba(96, 165, 250, 0.7);
        }

        .arrow {
            transition: transform 0.3s ease;
        }

        .arrow.open {
            transform: rotate(180deg);
        }

        .drag-handle {
            cursor: grab;
            padding: 8px;
            color: #94a3b8;
        }

        .drag-handle:active {
            cursor: grabbing;
        }

        /* Warning Banner for ALL mode */
        .all-divisions-warning {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 12px;
            box-shadow: 0 4px 12px rgba(245, 158, 11, 0.3);
            animation: pulseWarning 2s ease-in-out infinite;
        }

        .all-divisions-warning .icon {
            font-size: 1.5rem;
        }

        .all-divisions-warning .text {
            flex: 1;
        }

        .all-divisions-warning strong {
            display: block;
            margin-bottom: 4px;
            font-size: 1.1rem;
        }

        @keyframes pulseWarning {
            0%, 100% {
                box-shadow: 0 4px 12px rgba(245, 158, 11, 0.3);
            }
            50% {
                box-shadow: 0 4px 20px rgba(245, 158, 11, 0.5);
            }
        }

        /* Confirmation Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(135deg, #1e293b, #334155);
            border-radius: 16px;
            padding: 30px;
            max-width: 500px;
            border: 1px solid rgba(148, 163, 184, 0.2);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        .modal-header {
            font-size: 1.5rem;
            color: #f59e0b;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .modal-body {
            color: #cbd5e1;
            line-height: 1.6;
            margin-bottom: 20px;
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }
    </style>
</head>
<body>

    <div class="container" style="display: flex; flex-direction: row;">
        <div class="vertical-panel" style="width: 360px; min-width: 300px; max-width: 420px; background: linear-gradient(135deg, #232b3b 0%, #1e293b 100%); border-radius: 18px; margin: 30px 20px 30px 30px; padding: 28px 18px; display: flex; flex-direction: column; gap: 28px; height: fit-content; box-shadow: 0 8px 32px rgba(0,0,0,0.25);">
                        <!-- Add Status to Division Accordion (moved and restyled) -->
                        <div class="accordion" id="addStatusAccordion" style="background: #232b3b; border-radius: 12px; box-shadow: 0 2px 8px rgba(60,60,80,0.10); margin-bottom: 10px;">
                            <div class="accordion-item border-primary" style="background: #232b3b; border-radius: 12px;">
                                <h2 class="accordion-header" id="addStatusHeading">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#addStatusCollapse" aria-expanded="false" aria-controls="addStatusCollapse" style="background: linear-gradient(90deg, #6366f1 0%, #60a5fa 100%); color: #fff; font-weight: bold; border-radius: 12px 12px 0 0;">
                                        <i class="bi bi-plus-circle me-2"></i> Add Status to Division
                                    </button>
                                </h2>
                                <div id="addStatusCollapse" class="accordion-collapse collapse" aria-labelledby="addStatusHeading" data-bs-parent="#addStatusAccordion">
                                    <div class="accordion-body" style="background: #f1f5f9; border-radius: 0 0 12px 12px;">
                                        <form id="addStatusForm" onsubmit="return false;">
                                            <div class="mb-3">
                                                <label for="addStatusDivision" class="form-label">Division</label>
                                                <input id="addStatusDivision" class="form-control bg-white" readonly />
                                            </div>
                                            <div class="mb-3">
                                                <label for="addStatusNameSelect" class="form-label">Status Name</label>
                                                <select id="addStatusNameSelect" class="form-select" onchange="handleStatusSelectChange()"></select>
                                                <div class="form-text">Select an existing status or type a new one below if not listed.</div>
                                            </div>
                                            <div class="mb-3" style="display: none;" id="newStatusInputContainer">
                                                <label for="addStatusNameInput" class="form-label">New Status Name</label>
                                                <input type="text" id="addStatusNameInput" class="form-control" placeholder="Enter new status name...">
                                            </div>
                                            <div class="mb-3">
                                                <label for="addStatusPosition" class="form-label">Insert Position</label>
                                                <select id="addStatusPosition" class="form-select"></select>
                                            </div>
                                            <div class="mb-3">
                                                <label for="pizzaStatusesDropdown" class="form-label">Pizza Statuses (All)</label>
                                                <select id="pizzaStatusesDropdown" class="form-select"></select>
                                                <div class="form-text">All Pizza Statuses from pay_PizzaStatuses.json</div>
                                            </div>
                                            <div class="d-flex justify-content-end gap-2">
                                                <button type="reset" class="btn btn-secondary">Clear</button>
                                                <button type="button" class="btn btn-primary" id="addStatusConfirmBtn">Add Status</button>
                                            </div>
                                        </form>
                                    </div>
                                </div>
                            </div>
                        </div>
            <h3>üéõÔ∏è Control Center</h3>
            <div class="stats-panel" id="statsPanel">
                <div class="stat-card">
                    <div class="stat-value" id="totalOperators">81</div>
                    <div class="stat-label">Total Operators</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="validSteps">0</div>
                    <div class="stat-label">Valid Steps</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="invalidSteps">0</div>
                    <div class="stat-label">Steps with Issues</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="complianceRate">0%</div>
                    <div class="stat-label">Compliance Rate</div>
                </div>
            </div>
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color valid"></div>
                    <span>All operators have required certifications</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color invalid"></div>
                    <span>Some operators missing required certifications</span>
                </div>
            </div>
            <div class="search-bar">
                <span class="search-icon">üîç</span>
                <input type="text" id="globalSearch" class="search-input" placeholder="Search certifications, operators, or statuses..." oninput="handleGlobalSearch()">
                <button class="clear-search" onclick="clearGlobalSearch()" style="display: none;">√ó</button>
            </div>
            <div class="filter-options">
                <button class="filter-btn active" data-filter="all" onclick="setFilter('all')">All Statuses</button>
                <button class="filter-btn" data-filter="valid" onclick="setFilter('valid')">‚úì Valid Only</button>
                <button class="filter-btn" data-filter="invalid" onclick="setFilter('invalid')">‚ö† Invalid Only</button>
            </div>
            <div class="division-filter-section" style="margin: 15px 0;">
                <label style="display: block; margin-bottom: 8px; color: #94a3b8; font-size: 0.9rem;">üìç Filter by Division:</label>
                <select id="mainDivisionFilter" onchange="handleMainDivisionFilter()" style="width: 100%; padding: 10px; border-radius: 6px; border: 1px solid rgba(148, 163, 184, 0.2); background: rgba(30, 41, 59, 0.6); color: #e2e8f0; font-size: 0.95rem;">
                    <option value="ALL">üåê All Divisions</option>
                </select>
            </div>
            <button class="btn btn-danger" onclick="showIssues()" id="issuesBtn">‚ö† Show Issues</button>
            <button class="btn btn-success" id="saveBtn" onclick="saveChanges()" style="display: none;">üíæ Save Changes</button>
            <button class="bulk-btn success" onclick="showExportModal()">üìä Export Report</button>
            <button class="bulk-btn" onclick="showCertAnalytics()">üìà Analytics</button>
            <button class="bulk-btn danger" onclick="confirmClearAll()">üóëÔ∏è Clear All Certs</button>
        </div>
        <div class="workflow-canvas" style="flex: 1;">
            <div class="workflow-steps" id="workflowSteps">
                <!-- Steps will be dynamically generated here -->
            </div>
        </div>
    </div>

    <!-- Certification Details Panel -->
    <div class="details-panel" id="detailsPanel">
        <div class="details-header">
            <h3 id="detailsTitle">Certification Details</h3>
            <div class="details-subtitle" id="detailsSubtitle"></div>
            <button class="close-panel" onclick="closeDetailsPanel()">√ó</button>
        </div>
        <div class="details-content" id="detailsContent">
        </div>
    </div>

    <!-- Export Modal -->
    <div class="export-modal" id="exportModal">
        <div class="export-content">
            <h3>Export Options</h3>
            <div class="export-options">
                <div class="export-option" onclick="exportAsCSV()">
                    <h4>üìÑ CSV Export</h4>
                    <p>Export all requirements as CSV for Excel/Sheets</p>
                </div>
                <div class="export-option" onclick="exportComplianceReport()">
                    <h4>üìä Compliance Report</h4>
                    <p>Detailed compliance report with operator status</p>
                </div>
                <div class="export-option" onclick="exportBottleneckAnalysis()">
                    <h4>üö¶ Bottleneck Analysis</h4>
                    <p>Identify problematic statuses and certs</p>
                </div>
                <div class="export-option" onclick="exportJSON()">
                    <h4>üíæ JSON Backup</h4>
                    <p>Full configuration backup in JSON format</p>
                </div>
            </div>
            <button class="btn" onclick="closeExportModal()">Cancel</button>
        </div>
    </div>

    <!-- Operator Profile Modal -->
    <div class="operator-modal" id="operatorModal">
        <div class="operator-modal-content">
            <div class="operator-modal-header">
                <h2 id="operatorModalName">Operator Profile</h2>
                <p class="operator-modal-subtitle" id="operatorModalSubtitle"></p>
                <button class="close-operator-modal" onclick="closeOperatorModal()">√ó</button>
            </div>
            <div class="operator-modal-body" id="operatorModalBody">
                <!-- Content will be dynamically generated -->
            </div>
        </div>
    </div>

    <script>
        console.log('üöÄ Script loading started');
        
        let operators = [];
        let statusTypes = [];
        let certTypes = [];  // Raw cert types from database
        let certRequirements = {};
        let pizzaStatusRequirements = {};  // Store original pizza status requirements
        let currentWorkflow = [];
        let hasUnsavedChanges = false;
        let originalCertRequirements = {};
        let allExistingCerts = [];
        let currentAutocompleteIndex = -1;
        let currentFilter = 'all';
        let searchQuery = '';
        let editMode = false;
        let selectedDivision = 'ALL';  // Default to All Divisions (for edit mode)
        let mainDivisionFilter = 'ALL';  // Division filter for main operator view
        let editedRequirements = {};

        // Divisions to completely exclude from the system
        const EXCLUDED_DIVISIONS = ['PA - BROOKES', '2 - LAHORE', 'Majestic'];

        // Helper to check if a division matches a filter (handling "12 - PA" vs "12-PA")
        function isDivisionMatch(division, filter) {
            if (!division || !filter) return false;
            if (filter === 'ALL') return true;
            // Extract the numeric/code part (e.g., "12" from "12 - PA")
            const filterCode = filter.split(' - ')[0].trim();
            return division.includes(filterCode);
        }
        
        let changesMade = false;
        let sqlStatements = [];
        let operatorDivisionMap = {};
        let draggedStatusElement = null;
        let draggedStatusName = null;
        let currentStatusOrder = [];
        
        console.log('‚úÖ Variables declared successfully');
        console.log('   - currentFilter:', currentFilter);
        console.log('   - searchQuery:', searchQuery);

        // Certification name normalization for matching
        function normalizeCertName(name) {
            if (!name || typeof name !== 'string') return '';
            return name.toLowerCase().trim().replace(/\s+/g, ' ');
        }

        function certNamesMatch(cert1, cert2) {
            return normalizeCertName(cert1) === normalizeCertName(cert2);
        }

        function findMatchingCert(certName, certList) {
            if (!certList || !Array.isArray(certList)) return null;
            const normalized = normalizeCertName(certName);
            return certList.find(c => {
                const certType = typeof c === 'string' ? c : (c?.CertType || '');
                return normalizeCertName(certType) === normalized;
            });
        }

        // Build requirements structure from master definition
        function buildRequirementsFromPizzaStatus(pizzaRequirements, statusTypes) {
            const requirements = {};
            const excludedDivisions = ['PA - BROOKES', '2 - LAHORE'];
            
            // For each status type, find its pizza status and get requirements
            for (const st of statusTypes) {
                const status = st.Status;
                const division = st.DivisionID;
                const pizzaId = st.PizzaStatusID;
                
                // IGNORE DELETED STATUSES
                if (st.isDeleted === true || st.IsDelete === true || String(st.isDeleted) === 'true') {
                    continue; // Skip processing deleted statuses
                }

                // Skip excluded divisions
                if (excludedDivisions.some(excluded => division.includes(excluded))) {
                    continue;
                }
                
                if (!pizzaId || !pizzaRequirements[pizzaId]) {
                    continue;
                }
                
                const pizzaReq = pizzaRequirements[pizzaId];

                // Filter out non-operator statuses
                if (pizzaReq.is_operator !== true) {
                    continue;
                }

                const requiredCerts = pizzaReq.required_certifications.map(c => c.name);
                
                // Initialize status if not exists
                if (!requirements[status]) {
                    requirements[status] = {
                        order: st.OrderID || '',
                        divisions: {}
                    };
                }
                
                // Count operators in this division/status
                const operatorsInStatus = operators.filter(op => 
                    op.DivisionID === division && op.StatusName === status
                );
                
                // Store requirements for this status+division combo
                requirements[status].divisions[division] = {
                    order: st.OrderID || '',
                    pizzaStatusId: pizzaId,
                    pizzaStatusName: pizzaReq.pizza_status_name,
                    total_operators: operatorsInStatus.length,
                    required: requiredCerts.map(cert => ({
                        cert: cert,
                        count: operatorsInStatus.length,
                        total: operatorsInStatus.length,
                        percentage: 100.0
                    })),
                    common: [],
                    optional: []
                };
            }
            
            return requirements;
        }

        // Convert current requirements back to pizza status format for saving
        function convertToPizzaStatusFormat(requirements) {
            const pizzaGroups = {};
            
            // Step 1: Build a map of Status Name -> Pizza ID to fill in gaps
            const statusToPizzaIdMap = {};
            for (const [statusName, statusData] of Object.entries(requirements)) {
                const divisions = statusData.divisions || {};
                for (const divData of Object.values(divisions)) {
                    if (divData.pizzaStatusId) {
                        statusToPizzaIdMap[statusName] = divData.pizzaStatusId;
                        statusToPizzaIdMap[statusName.toUpperCase()] = divData.pizzaStatusId;
                    }
                }
            }

            // Group requirements by pizza status
            for (const [statusName, statusData] of Object.entries(requirements)) {
                const divisions = statusData.divisions || {};
                
                for (const [division, divData] of Object.entries(divisions)) {
                    let pizzaId = divData.pizzaStatusId;
                    
                    // Fallback: Try to infer ID from status name if missing
                    if (!pizzaId && statusToPizzaIdMap[statusName]) {
                        pizzaId = statusToPizzaIdMap[statusName];
                        console.log(`‚ö†Ô∏è Inferred Pizza ID for ${statusName} (${division}): ${pizzaId}`);
                    }

                    if (!pizzaId) continue;
                    
                    // Initialize pizza status group if not exists
                    if (!pizzaGroups[pizzaId]) {
                        pizzaGroups[pizzaId] = {
                            pizza_status_id: pizzaId,
                            pizza_status_name: divData.pizzaStatusName || 'Unknown',
                            description: divData.pizzaStatusName || '',
                            is_operator: true,
                            threshold: 0.80,
                            operators_analyzed: divData.total_operators || 0,
                            required_certifications: [],
                            status_mappings: []
                        };
                    }
                    
                    // Update required certifications (MERGE with DIVISION SPECIFICITY)
                    const currentCerts = (divData.required || []).map(c => c.cert);
                    currentCerts.forEach(certName => {
                        // Check if exact match (Same Cert AND Same Division OR Global) exists
                        const existingCert = pizzaGroups[pizzaId].required_certifications.find(
                            pc => normalizeCertName(pc.name) === normalizeCertName(certName) &&
                                  (pc.division === division)
                        );
                        
                        if (!existingCert) {
                            pizzaGroups[pizzaId].required_certifications.push({
                                name: certName,
                                division: division, // Persist the division!
                                coverage: {
                                    count: divData.total_operators,
                                    total: divData.total_operators,
                                    percentage: 100.0
                                }
                            });
                        }
                    });
                    
                    // Add this status+division to the mappings
                    const existingMapping = pizzaGroups[pizzaId].status_mappings.find(
                        m => m.status === statusName && m.division === division
                    );
                    
                    if (!existingMapping) {
                        pizzaGroups[pizzaId].status_mappings.push({
                            status: statusName,
                            division: division,
                            order: divData.order || statusData.order || ''
                        });
                    }
                }
            }
            
            // Sort status mappings within each pizza status
            for (const pizzaReq of Object.values(pizzaGroups)) {
                pizzaReq.status_mappings.sort((a, b) => {
                    const orderA = String(a.order);
                    const orderB = String(b.order);
                    if (orderA !== orderB) return orderA.localeCompare(orderB);
                    return a.division.localeCompare(b.division);
                });
            }
            
            return pizzaGroups;
        }

        // Ideal lifecycle flow
        const idealFlow = [
            { step: 1, status: 'REGISTRATION' },
            { step: 2, status: 'ONBOARDING' },
            { step: 3, status: 'CREDENTIALING' },
            { step: 4, status: 'DOT SCREENING' },
            { step: 5, status: 'ORIENTATION-BIG STAR SAFETY & SERVICE' },
            { step: 7, status: 'APPROVED-ORIENTATION BTW' },
            { step: 8, status: 'COMPLIANCE REVIEW' },
            { step: 9, status: 'SBPC APPROVED FOR SERVICE' },
            { step: 11, status: 'APPROVED FOR CONTRACTING' },
            { step: 13, status: 'IN-SERVICE' }
        ];

        // Load data
        async function loadData() {
            try {
                console.log('üöÄ Starting data load...');
                
                // Cache buster to force fresh load
                const cacheBuster = '?v=' + Date.now();
                
                console.log('üì• Fetching operators...');
                // Load operators - now in same directory
                const operatorsResponse = await fetch('pay_Operators.json' + cacheBuster);
                if (!operatorsResponse.ok) {
                    throw new Error('Failed to load operators data: ' + operatorsResponse.status);
                }
                operators = await operatorsResponse.json();
                console.log('‚úÖ Operators loaded successfully');
                
                console.log('üîµ Loaded operators:', operators.length);
                const willie = operators.find(op => op.LastName === 'Quainton');
                if (willie) {
                    console.log('üîµ Willie Quainton found!');
                    console.log('  - DivisionID:', willie.DivisionID);
                    console.log('  - StatusName:', willie.StatusName);
                    console.log('  - Certifications:', willie.certifications?.length || 0);
                } else {
                    console.log('‚ùå Willie Quainton NOT found');
                }

                console.log('üì• Fetching cert types...');
                // Load cert types from database
                const certTypesResponse = await fetch('../data/pay_CertTypes.json' + cacheBuster);
                if (!certTypesResponse.ok) {
                    throw new Error('Failed to load cert types: ' + certTypesResponse.status);
                }
                certTypes = await certTypesResponse.json();
                console.log('‚úÖ Cert types loaded:', certTypes.length, 'certification types');
                
                console.log('üì• Fetching pizza status requirements...');
                // Load pizza status requirements (inference-based)
                const pizzaReqResponse = await fetch('../data/pay_PizzaStatusRequirements.json' + cacheBuster);
                if (!pizzaReqResponse.ok) {
                    throw new Error('Failed to load pizza status requirements: ' + pizzaReqResponse.status);
                }
                pizzaStatusRequirements = await pizzaReqResponse.json();
                console.log('‚úÖ Pizza status requirements loaded:', Object.keys(pizzaStatusRequirements).length, 'pizza statuses');
                
                // Load status types for mapping
                console.log('üì• Fetching status types...');
                const statusTypesResponse = await fetch('../data/pay_StatusTypes.json' + cacheBuster);
                if (!statusTypesResponse.ok) {
                    throw new Error('Failed to load status types: ' + statusTypesResponse.status);
                }
                statusTypes = await statusTypesResponse.json();
                console.log('‚úÖ Status types loaded:', statusTypes.length, 'status type mappings');
                
                // Load certification aliases
                console.log('üì• Fetching certification aliases...');
                const aliasesResponse = await fetch('../config/certification_aliases.json' + cacheBuster);
                if (!aliasesResponse.ok) {
                    throw new Error('Failed to load certification aliases: ' + aliasesResponse.status);
                }
                const certificationAliases = await aliasesResponse.json();
                console.log('‚úÖ Certification aliases loaded');
                
                // Build cert requirements structure from pizza status definitions
                certRequirements = buildRequirementsFromPizzaStatus(pizzaStatusRequirements, statusTypes);
                console.log('‚úÖ Requirements built from pizza status definitions');
                
                // Keep a copy of original data for comparison
                originalCertRequirements = JSON.parse(JSON.stringify(certRequirements));
                
                console.log('Loaded cert requirements for statuses:', Object.keys(certRequirements).length);

                console.log('üèóÔ∏è Building existing certs list...');
                // Build list of all existing certifications
                buildExistingCertsList();
                console.log('‚úÖ Existing certs list built');

                console.log('üé® Initializing workflow...');
                // Initialize workflow
                // initializeDynamicWorkflow(); // Logic moved to renderWorkflow for reactivity
                currentWorkflow = [...idealFlow];
                
                console.log('üîÑ Initializing workflow with', currentWorkflow.length, 'steps');
                console.log('üìä Current workflow:', currentWorkflow);
                console.log('üë• Total operators loaded:', operators.length);
                console.log('üéØ Current filter:', currentFilter);
                console.log('üîç Search query:', searchQuery);
                
                console.log('üé® Rendering workflow...');
                renderWorkflow();
                console.log('‚úÖ Workflow rendered');
                
                console.log('üìä Updating stats...');
                updateStats();
                console.log('‚úÖ Stats updated');
                
                console.log('üìã Populating main division filter...');
                populateMainDivisionFilter();
                console.log('‚úÖ Main division filter populated');
                
                console.log('‚úÖ Initialization complete');
            } catch (error) {
                console.error('‚ùå Error loading data:', error);
                console.error('‚ùå Error stack:', error.stack);
                console.error('‚ùå Error message:', error.message);
                alert('Error loading data: ' + error.message + '\nCheck console for details.');
            }
        }

        // Initialize workflow based on Dynamic Status Types
        function initializeDynamicWorkflow() {
            if (mainDivisionFilter === 'ALL') {
                // Use legacy ideal flow as fallback or aggregated view
                currentWorkflow = [...idealFlow];
            } else {
                // Use StatusTypes for filtering, matching Python script logic
                // Ensure statusTypes and pizzaStatuses are loaded
                if (typeof window.statusTypes === 'undefined') {
                    var xhrST = new XMLHttpRequest();
                    xhrST.open('GET', '../data/pay_StatusTypes.json', false);
                    xhrST.send(null);
                    if (xhrST.status === 200) {
                        window.statusTypes = JSON.parse(xhrST.responseText);
                    } else {
                        window.statusTypes = [];
                    }
                }
                if (typeof window.pizzaStatuses === 'undefined') {
                    var xhrPS = new XMLHttpRequest();
                    xhrPS.open('GET', '../data/pay_PizzaStatuses.json', false);
                    xhrPS.send(null);
                    if (xhrPS.status === 200) {
                        window.pizzaStatuses = JSON.parse(xhrPS.responseText);
                    } else {
                        window.pizzaStatuses = [];
                    }
                }
                const statusTypesArr = window.statusTypes;
                const pizzaStatusesArr = window.pizzaStatuses;
                const pizzaStatusMap = {};
                pizzaStatusesArr.forEach(p => { if (p.ID) pizzaStatusMap[p.ID] = p; });

                // Filter StatusTypes for the selected division, matching the script logic
                let divStatuses = statusTypesArr.filter(st => {
                    return (
                        st.DivisionID === mainDivisionFilter &&
                        !(st.isDeleted === true || st.IsDelete === true || String(st.isDeleted).trim() === '1' || String(st.IsDelete).trim() === '1' || String(st.isDeleted).trim().toLowerCase() === 'true' || String(st.IsDelete).trim().toLowerCase() === 'true') &&
                        st.PizzaStatusID &&
                        pizzaStatusMap[st.PizzaStatusID] &&
                        (String(st.isActive || '1').trim() === '1' || st.isActive === true) &&
                        pizzaStatusMap[st.PizzaStatusID].IsOperator === true
                    );
                });

                // Sort by OrderID (as integer, fallback to 9999 if missing)
                divStatuses.sort((a, b) => {
                    const ordA = parseInt(a.OrderID) || 9999;
                    const ordB = parseInt(b.OrderID) || 9999;
                    return ordA - ordB;
                });

                if (divStatuses.length > 0) {
                    currentWorkflow = divStatuses.map((st, idx) => ({
                        step: (parseInt(st.OrderID) || (idx + 1)),
                        status: st.Status,
                        statusId: st.Id || st.ID || null
                    }));
                } else {
                    // Fallback if no specific configuration found
                    console.warn(`No StatusTypes found for ${mainDivisionFilter}, using default flow.`);
                    currentWorkflow = [...idealFlow];
                }
            }
        }

        // Render the workflow
        function renderWorkflow() {
            // Re-initialize workflow based on current filter state
            // This ensures we see the correct list of statuses for the selected division
            if (mainDivisionFilter !== 'ALL') {
                initializeDynamicWorkflow();
            } else {
                currentWorkflow = [...idealFlow];
            }

            // Check if we accidentally got into legacy "Edit Mode" state and reset it
            if (typeof editMode !== 'undefined' && editMode) {
                 editMode = false;
                 document.querySelector('.control-panel').style.display = 'block';
            }

            console.log('üé® renderWorkflow() called');
            console.log('   - currentWorkflow length:', currentWorkflow.length);
            console.log('   - currentFilter:', currentFilter);
            console.log('   - searchQuery:', searchQuery);
            
            const container = document.getElementById('workflowSteps');
            console.log('   - container element:', container ? 'Found' : 'NOT FOUND');
            if (!container) return; // Guard clause
            
            container.innerHTML = '';

            // Add warning banner if ALL divisions mode (INTEGRATED FROM EDIT MODE)
            if (mainDivisionFilter === 'ALL') {
                const warningDiv = document.createElement('div');
                warningDiv.className = 'all-divisions-warning';
                warningDiv.style.marginBottom = '20px';
                warningDiv.innerHTML = `
                    <div class="icon">‚ö†Ô∏è</div>
                    <div class="text">
                        <strong>GLOBAL EDIT MODE - ALL DIVISIONS</strong><br>
                        Changes made here may overwrite individual division customizations if not careful.
                    </div>
                `;
                container.appendChild(warningDiv);
            }
            
            let renderedCount = 0;

            currentWorkflow.forEach((flowStep, index) => {
                // Apply filters
                const statusName = flowStep.status;
                let operatorsInStep = operators.filter(op => 
                    op.StatusName === statusName || 
                    (op.StatusName && op.StatusName.toUpperCase() === statusName.toUpperCase())
                );
                
                // Apply division filter
                if (mainDivisionFilter !== 'ALL') {
                    operatorsInStep = operatorsInStep.filter(op => op.DivisionID === mainDivisionFilter);
                }
                
                const allRequiredCerts = getRequiredCertsForStatus(statusName);
                const validation = validateOperatorsInStep(operatorsInStep, allRequiredCerts, index);
                
                console.log(`   Step ${index + 1}: ${statusName} - valid: ${validation.isValid}, operators: ${operatorsInStep.length}, certs: ${allRequiredCerts.length}`);
                
                // Filter logic
                if (currentFilter === 'valid' && !validation.isValid) {
                    console.log(`     ‚è≠Ô∏è Skipping (filter: valid only)`);
                    return;
                }
                if (currentFilter === 'invalid' && validation.isValid) {
                    console.log(`     ‚è≠Ô∏è Skipping (filter: invalid only)`);
                    return;
                }
                
                // Search logic
                if (searchQuery) {
                    const statusMatch = statusName.toLowerCase().includes(searchQuery);
                    const certsMatch = allRequiredCerts.some(cert => 
                        cert.toLowerCase().includes(searchQuery)
                    );
                    const operatorsMatch = operatorsInStep.some(op => 
                        op.FullName?.toLowerCase().includes(searchQuery)
                    );
                    if (!statusMatch && !certsMatch && !operatorsMatch) {
                        console.log(`     ‚è≠Ô∏è Skipping (no search match)`);
                        return;
                    }
                }
                
                console.log(`     ‚úÖ Rendering step`);
                renderedCount++;
                const stepCard = createStepCard(flowStep, index);
                container.appendChild(stepCard);
            });


            console.log(`üé® Rendered ${renderedCount} of ${currentWorkflow.length} steps`);

            // Add drag and drop event listeners
            addDragAndDropListeners();
        }

        // Create a step card
        function createStepCard(flowStep, index) {
            const statusName = flowStep.status;
            let operatorsInStep = operators.filter(op => 
                op.StatusName === statusName || 
                (op.StatusName && op.StatusName.toUpperCase() === statusName.toUpperCase())
            );
            
            // Apply division filter
            if (mainDivisionFilter !== 'ALL') {
                operatorsInStep = operatorsInStep.filter(op => op.DivisionID === mainDivisionFilter);
            }

            // Get required certifications for this status
            const allRequiredCerts = getRequiredCertsForStatus(statusName);
            
            console.log(`\nüìã Step ${index + 1} (${statusName}):`);
            console.log(`   All required certs (${allRequiredCerts.length}):`, allRequiredCerts);
            
            // Get certs from previous steps to exclude (show only in FIRST occurrence)
            const previousCerts = new Set();
            for (let i = 0; i < index; i++) {
                const prevStatus = currentWorkflow[i].status;
                const prevRequiredCerts = getRequiredCertsForStatus(prevStatus);
                console.log(`   Previous step ${i + 1} (${prevStatus}) had:`, prevRequiredCerts);
                prevRequiredCerts.forEach(cert => previousCerts.add(cert));
            }
            
            console.log(`   Total previous certs (${previousCerts.size}):`, Array.from(previousCerts));
            
            // Only show certs that haven't appeared in previous steps (first occurrence only)
            const certsToDisplay = allRequiredCerts.filter(cert => !previousCerts.has(cert));
            
            // Build map of which divisions require each cert
            const certDivisionMap = {};
            const statusData = certRequirements[statusName] || certRequirements[statusName.toUpperCase()];
            if (statusData && statusData.divisions) {
                Object.entries(statusData.divisions).forEach(([divId, divData]) => {
                    (divData.required || []).forEach(certObj => {
                        const certName = certObj.cert;
                        if (!certDivisionMap[certName]) {
                            certDivisionMap[certName] = [];
                        }
                        certDivisionMap[certName].push(divId);
                    });
                });
            }
            
            console.log(`   Certs to display (${certsToDisplay.length}):`, certsToDisplay);
            console.log(`   Cert division map:`, certDivisionMap);
            
            // Check for duplicates or near-duplicates
            const duplicateCheck = allRequiredCerts.filter(cert => 
                previousCerts.has(cert)
            );
            if (duplicateCheck.length > 0) {
                console.log(`   üîÑ Filtered out duplicates (${duplicateCheck.length}):`, duplicateCheck);
            }

            // Check if all operators have required certs (cumulative - includes previous steps)
            const validation = validateOperatorsInStep(operatorsInStep, allRequiredCerts, index);

            const card = document.createElement('div');
            card.className = `step-card ${validation.isValid ? 'valid' : 'invalid'}`;
            card.draggable = true;
            card.dataset.index = index;
            card.dataset.status = statusName;
            
            // Get divisions dynamically based on filter
            let divisionsText;
            if (mainDivisionFilter === 'ALL') {
                // Show all divisions that have this status in pizza status requirements
                const divisionsForStatus = new Set();
                Object.values(pizzaStatusRequirements).forEach(pizzaStatus => {
                    (pizzaStatus.status_mappings || []).forEach(mapping => {
                        if (mapping.status === statusName) {
                            divisionsForStatus.add(mapping.division);
                        }
                    });
                });
                const divList = Array.from(divisionsForStatus).sort();
                divisionsText = divList.length > 0 ? divList.join(', ') : 'No divisions';
            } else {
                // Show only the filtered division
                divisionsText = mainDivisionFilter;
            }

            card.innerHTML = `
                <div class="step-header">
                    <div class="step-number">${index + 1}</div>
                    <div class="step-info">
                        <div class="step-title">${statusName}</div>
                        <div class="step-meta">
                            ${!isNaN(flowStep.step) ? `<span>Original Step: ${flowStep.step}</span><span>|</span>` : ''}
                            <span>Division${mainDivisionFilter === 'ALL' ? 's' : ''}: ${divisionsText}</span>
                            <span>|</span>
                            <span>${certsToDisplay.length} New Required Cert${certsToDisplay.length !== 1 ? 's' : ''}</span>
                            ${previousCerts.size > 0 ? `<span>|</span><span style="color: #94a3b8;">${previousCerts.size} from previous steps</span>` : ''}
                        </div>
                    </div>
                    <div class="status-indicator ${validation.isValid ? 'valid' : 'invalid'}">
                        <div class="status-dot"></div>
                        ${validation.isValid ? '‚úì Valid' : '‚ö† Issues'}
                    </div>
                </div>
                
                <!-- Status Actions -->
                ${mainDivisionFilter !== 'ALL' ? `
                <div style="position: absolute; top: 10px; right: 140px;">
                    <button class="delete-cert-type-btn" onclick="deleteStatus('${statusName}', '${mainDivisionFilter}')" title="Delete status '${statusName}' from Division ${mainDivisionFilter}">
                        üóëÔ∏è Remove Status
                    </button>
                </div>` : ''}

                <div class="operators-dropdown">
                    <div class="dropdown-trigger" onclick="toggleDropdown(this)">
                        <span>
                            <strong>Operators in this step</strong>
                            <span class="count">${operatorsInStep.length}</span>
                        </span>
                        <span class="arrow">‚ñº</span>
                    </div>
                    <div class="dropdown-content">
                        ${operatorsInStep.length > 0 ? 
                            operatorsInStep.map(op => {
                                // Get certs needed for THIS operator's division - CUMULATIVE from all previous steps
                                const opDivision = op.DivisionID || '';
                                const opStatus = op.StatusName || '';
                                
                                // Use the new helper function to get required certs for this operator
                                const allCertsNeeded = getRequiredCertsForOperator(opDivision, opStatus);

                                // Get operator's certifications
                                const operatorCerts = op.certifications || [];
                                
                                // Calculate cert status
                                let validCount = 0;
                                let expiredCount = 0;
                                let missingCount = 0;
                                let notApprovedCount = 0;

                                allCertsNeeded.forEach(certName => {
                                    const cert = findMatchingCert(certName, operatorCerts);
                                    if (cert) {
                                        // Check if approved (Status != '0' AND has dates)
                                        const isApproved = cert.Status !== '0' && (cert.IssueDate || cert.ExpireDate);
                                        
                                        if (!isApproved) {
                                            // Not approved yet
                                            notApprovedCount++;
                                            missingCount++; // Count as missing until approved
                                        } else {
                                            // Approved - check if expired
                                            const expireDate = cert.ExpireDate ? new Date(cert.ExpireDate) : null;
                                            const isExpired = expireDate && expireDate < new Date();
                                            if (isExpired) {
                                                expiredCount++;
                                            } else {
                                                validCount++;
                                            }
                                        }
                                    } else {
                                        missingCount++;
                                    }
                                });
                                
                                if (op.LastName === 'Quainton') {
                                    console.log('  COUNTS - valid:', validCount, 'expired:', expiredCount, 'missing:', missingCount);
                                }

                                const total = validCount + expiredCount + missingCount;
                                const validPercent = total > 0 ? (validCount / total * 100) : 0;
                                const expiredPercent = total > 0 ? (expiredCount / total * 100) : 0;
                                const missingPercent = total > 0 ? (missingCount / total * 100) : 0;

                                return `
                                    <div class="operator-item" onclick="showOperatorProfile('${op.ID}')" style="cursor: pointer;" title="${validCount} Valid, ${expiredCount} Expired, ${missingCount} Missing">
                                        <span class="operator-name">${op.FirstName} ${op.LastName}</span>
                                        <div class="operator-progress">
                                            ${validPercent > 0 ? `<div class="operator-progress-segment valid" style="width: ${validPercent}%"></div>` : ''}
                                            ${expiredPercent > 0 ? `<div class="operator-progress-segment expired" style="width: ${expiredPercent}%"></div>` : ''}
                                            ${missingPercent > 0 ? `<div class="operator-progress-segment missing" style="width: ${missingPercent}%"></div>` : ''}
                                        </div>
                                    </div>
                                `;
                            }).join('') : 
                            '<div class="operator-item"><span style="color: #94a3b8;">No operators in this step</span></div>'
                        }
                    </div>
                </div>

                <div class="cert-details">
                    <div class="cert-title">New Required Certifications (${certsToDisplay.length}):</div>
                    <div class="cert-list cert-list-editable drop-zone" data-status="${statusName}" ondrop="handleCertDrop(event, this)" ondragover="handleCertDragOver(event)">
                        ${certsToDisplay.length > 0 ? 
                            certsToDisplay.slice(0, 50).map(cert => {
                                return `
                                    <span class="cert-badge" draggable="true" ondragstart="handleCertDragStart(event, this)" data-cert="${cert}" onclick="showCertDetails('${cert.replace(/'/g, "\\'")}', '${statusName}')" style="cursor: pointer;">
                                        ${cert}
                                        <span class="remove-cert" onclick="event.stopPropagation(); removeCert(event, '${statusName}', '${cert.replace(/'/g, "\\'")}')">√ó</span>
                                    </span>
                                `;
                            }).join('') :
                            '<span style="color: #94a3b8;">No new certifications required at this step</span>'
                        }
                    </div>
                    <div class="add-cert-section">
                        <div class="add-cert-input">
                            <div class="add-cert-input-wrapper">
                                <input type="text" 
                                       placeholder="Type to search or add new certification..." 
                                       id="newCert_${index}" 
                                       autocomplete="off"
                                       oninput="handleCertInput(event, ${index})"
                                       onkeydown="handleCertKeydown(event, ${index})"
                                       onfocus="handleCertFocus(event, ${index})"
                                       onblur="handleCertBlur(event, ${index})" />
                                <div class="autocomplete-dropdown" id="autocomplete_${index}"></div>
                            </div>
                            <button class="btn btn-primary btn-small" onclick="addCert('${statusName}', ${index})">+ Add</button>
                        </div>
                    </div>
                </div>
            `;

            return card;
        }

        // Get required certifications for a status (using CertTypes table directly)
        function getRequiredCertsForStatus(statusName) {
            const certs = new Set();
            
            console.log(`\nüîç getRequiredCertsForStatus('${statusName}') with division filter: '${mainDivisionFilter}'`);
            
            // Step 1: Find pizza statuses that map to this lifecycle status
            const relevantPizzaStatusIds = new Set();
            Object.values(pizzaStatusRequirements).forEach(pizzaStatus => {
                const matchingMappings = (pizzaStatus.status_mappings || []).filter(mapping => {
                    if (mapping.status === statusName) {
                        if (mainDivisionFilter === 'ALL') {
                            return true;
                        } else {
                            return mapping.division === mainDivisionFilter;
                        }
                    }
                    return false;
                });
                
                if (matchingMappings.length > 0) {
                    relevantPizzaStatusIds.add(pizzaStatus.pizza_status_id);
                    console.log(`   üì¶ Pizza Status: ${pizzaStatus.pizza_status_name} (${pizzaStatus.pizza_status_id})`);
                    console.log(`      Mappings: ${matchingMappings.map(m => m.division).join(', ')}`);
                }
            });
            
            console.log(`   üéØ Found ${relevantPizzaStatusIds.size} relevant pizza status IDs`);
            
            // Step 2: Get cert types that have these pizza status IDs and match division filter
            certTypes.forEach(certType => {
                const pizzaStatusId = certType.PizzaStatusID;
                const divisionId = certType.DivisionID;
                const certName = certType.Certification;
                
                // Check if this cert type has a relevant pizza status ID
                if (pizzaStatusId && relevantPizzaStatusIds.has(pizzaStatusId)) {
                    // Check division filter
                    if (mainDivisionFilter === 'ALL') {
                        certs.add(certName);
                    } else {
                        // Require exact DivisionID match (Python logic)
                        if (divisionId && divisionId === mainDivisionFilter) {
                            certs.add(certName);
                        }
                    }
                }
            });

            const result = Array.from(certs).sort();
            console.log(`   ‚úÖ TOTAL Certs for ${statusName} (division: ${mainDivisionFilter}): ${result.length}`);
            if (result.length > 0) {
                console.log(`      Certs: ${result.join(', ')}`);
            }
            return result;
        }

        // Get required certs for an operator based on their division and cumulative statuses
        function getRequiredCertsForOperator(operatorDivision, statusName) {
            const certs = new Set();
            
            // Find operator's current step in the workflow
            const currentStepIndex = idealFlow.findIndex(s => s.status === statusName);
            
            if (currentStepIndex >= 0) {
                // Get all statuses up to and including current (cumulative)
                const relevantStatuses = idealFlow.slice(0, currentStepIndex + 1).map(s => s.status);
                
                // Collect requirements from all these statuses for operator's division
                relevantStatuses.forEach(status => {
                    Object.values(pizzaStatusRequirements).forEach(pizzaStatus => {
                        (pizzaStatus.status_mappings || []).forEach(mapping => {
                            if (mapping.status === status && mapping.division === operatorDivision) {
                                (pizzaStatus.required_certifications || []).forEach(cert => {
                                    if (cert.division === operatorDivision) {
                                        certs.add(cert.name);
                                    }
                                });
                            }
                        });
                    });
                });
            }
            
            return Array.from(certs);
        }

        // Build list of all existing certifications from CertTypes (treating each cert+division as unique)
        function buildExistingCertsList() {
            const certsArray = [];
            
            // Add each cert type as a unique entry (no grouping by name)
            certTypes.forEach(certType => {
                const certName = certType.Certification;
                const division = certType.DivisionID;
                
                if (!certName) return;
                
                // Exclude unwanted divisions globally
                if (division && EXCLUDED_DIVISIONS.some(ex => division.toUpperCase().includes(ex.toUpperCase()))) return;
                
                // Each cert type is unique - don't group by name
                certsArray.push({
                    name: certName,
                    division: division || 'No division',
                    pizzaStatusId: certType.PizzaStatusID || null,
                    certTypeId: certType.CertID
                });
            });
            
            // Group only for display purposes (to show "Used in X divisions")
            const certsMap = new Map();
            certsArray.forEach(cert => {
                if (!certsMap.has(cert.name)) {
                    certsMap.set(cert.name, {
                        name: cert.name,
                        divisions: new Set(),
                        pizzaStatuses: new Set(),
                        entries: []
                    });
                }
                const entry = certsMap.get(cert.name);
                entry.divisions.add(cert.division);
                if (cert.pizzaStatusId) {
                    entry.pizzaStatuses.add(cert.pizzaStatusId);
                }
                entry.entries.push(cert);
            });
            
            // Convert to array with metadata
            allExistingCerts = Array.from(certsMap.entries()).map(([certName, data]) => ({
                name: certName,
                divisions: Array.from(data.divisions).sort(),
                divisionCount: data.divisions.size,
                pizzaStatusCount: data.pizzaStatuses.size,
                entries: data.entries // Keep individual entries for filtering
            }));
            
            // Sort by division count (most common first)
            allExistingCerts.sort((a, b) => b.divisionCount - a.divisionCount);
            
            console.log(`Found ${allExistingCerts.length} unique certifications from CertTypes (${certsArray.length} total cert types)`);
        }

        // Handle input in cert field (autocomplete)
        function handleCertInput(event, stepIndex) {
            const input = event.target;
            const value = input.value.trim().toLowerCase();
            const dropdown = document.getElementById(`autocomplete_${stepIndex}`);
            
            if (!value) {
                dropdown.classList.remove('active');
                return;
            }
            
            // Get current division filter (use selectedDivision for edit mode)
            const currentFilter = editMode ? selectedDivision : mainDivisionFilter;
            console.log(`üîç Autocomplete filter: editMode=${editMode}, currentFilter='${currentFilter}'`);
            
            // Filter certifications by search term
            let matches = allExistingCerts.filter(cert => 
                cert.name.toLowerCase().includes(value)
            );
            
            console.log(`   Found ${matches.length} matches for search term '${value}'`);
            
            // Filter by division if specific division selected
            if (currentFilter !== 'ALL') {
                const beforeCount = matches.length;
                matches = matches.filter(cert => {
                    // Check if ANY of the cert's individual entries (cert types) match the filter division
                    const hasMatch = cert.entries.some(entry => {
                        // Handle both "12 - PA" and "12-PA" formats
                        const divNum = currentFilter.replace(' - ', '-').split('-')[0];
                        const matches = entry.division && entry.division.includes(divNum);
                        return matches;
                    });
                    return hasMatch;
                });
                console.log(`   After division filter '${currentFilter}': ${matches.length} matches (was ${beforeCount})`);
                if (matches.length > 0 && matches.length <= 3) {
                    console.log(`   Sample matches:`, matches.map(m => `${m.name} [${m.divisions.join(', ')}]`));
                }
            }
            
            // Limit to top 20 matches
            matches = matches.slice(0, 20);
            
            if (matches.length === 0) {
                const filterMsg = currentFilter !== 'ALL' ? ` for division ${currentFilter}` : '';
                dropdown.innerHTML = `<div class="autocomplete-no-results">No matches found${filterMsg}. Press Enter to add as new certification.</div>`;
                dropdown.classList.add('active');
            } else {
                dropdown.innerHTML = matches.map((cert, idx) => {
                    let displayDivisions = cert.divisions;
                    
                    // If filtering, only show matching divisions in the subtitle to reduce noise
                    if (currentFilter !== 'ALL') {
                        // Use helper to find matches
                        displayDivisions = displayDivisions.filter(d => isDivisionMatch(d, currentFilter));
                    }
                    
                    // Filter excluded divisions from display
                    displayDivisions = displayDivisions.filter(d => !EXCLUDED_DIVISIONS.some(ex => d.toUpperCase().includes(ex.toUpperCase())));
                    
                    const divisionsText = displayDivisions.length > 0 
                        ? displayDivisions.slice(0, 3).join(', ') + (displayDivisions.length > 3 ? '...' : '')
                        : (currentFilter !== 'ALL' ? currentFilter : 'No division');
                    
                    return `
                        <div class="autocomplete-item ${idx === 0 ? 'highlighted' : ''}" 
                             data-cert="${cert.name}"
                             onmousedown="selectCert(event, '${cert.name.replace(/'/g, "\\'")}', ${stepIndex})">
                            <div class="cert-name">${cert.name}</div>
                            <div class="cert-status-list">üìç ${divisionsText} | Used in ${cert.pizzaStatusCount} pizza status${cert.pizzaStatusCount > 1 ? 'es' : ''}</div>
                        </div>
                    `;
                }).join('');
                dropdown.classList.add('active');
                currentAutocompleteIndex = 0;
            }
        }

        // Handle keyboard navigation in autocomplete
        function handleCertKeydown(event, stepIndex) {
            const dropdown = document.getElementById(`autocomplete_${stepIndex}`);
            const items = dropdown.querySelectorAll('.autocomplete-item');
            
            if (event.key === 'ArrowDown') {
                event.preventDefault();
                if (currentAutocompleteIndex < items.length - 1) {
                    items[currentAutocompleteIndex]?.classList.remove('highlighted');
                    currentAutocompleteIndex++;
                    items[currentAutocompleteIndex]?.classList.add('highlighted');
                    items[currentAutocompleteIndex]?.scrollIntoView({ block: 'nearest' });
                }
            } else if (event.key === 'ArrowUp') {
                event.preventDefault();
                if (currentAutocompleteIndex > 0) {
                    items[currentAutocompleteIndex]?.classList.remove('highlighted');
                    currentAutocompleteIndex--;
                    items[currentAutocompleteIndex]?.classList.add('highlighted');
                    items[currentAutocompleteIndex]?.scrollIntoView({ block: 'nearest' });
                }
            } else if (event.key === 'Enter') {
                event.preventDefault();
                const highlighted = items[currentAutocompleteIndex];
                if (highlighted) {
                    const certName = highlighted.dataset.cert;
                    selectCert(event, certName, stepIndex);
                } else {
                    // No selection, treat as new cert
                    const statusName = currentWorkflow[stepIndex].status;
                    addCert(statusName, stepIndex);
                }
            } else if (event.key === 'Escape') {
                dropdown.classList.remove('active');
            }
        }

        // Handle focus on input
        function handleCertFocus(event, stepIndex) {
            const input = event.target;
            if (input.value.trim()) {
                handleCertInput(event, stepIndex);
            }
        }

        // Handle blur on input
        function handleCertBlur(event, stepIndex) {
            // Delay to allow click on dropdown item
            setTimeout(() => {
                const dropdown = document.getElementById(`autocomplete_${stepIndex}`);
                dropdown.classList.remove('active');
                currentAutocompleteIndex = -1;
            }, 200);
        }

        // Select certification from autocomplete
        function selectCert(event, certName, stepIndex) {
            event.preventDefault();
            const input = document.getElementById(`newCert_${stepIndex}`);
            input.value = certName;
            
            const dropdown = document.getElementById(`autocomplete_${stepIndex}`);
            dropdown.classList.remove('active');
            
            // Auto-add the selected cert
            const statusName = currentWorkflow[stepIndex].status;
            addCertToStatus(statusName, certName);
            input.value = '';
            renderWorkflow();
            markUnsaved();
        }

        // Check if operator has required certs considering step order
        function checkOperatorHasRequiredCerts(operator, requiredCerts, currentStepIndex) {
            if (!operator.certifications || operator.certifications.length === 0) {
                return requiredCerts.length === 0;
            }

            // Get all certs the operator has
            const operatorCerts = new Set(
                operator.certifications.map(cert => cert.CertType)
            );

            // Also check if operator should have completed certs from previous steps
            let allRequiredCerts = new Set(requiredCerts);
            
            // Add certs from all previous steps
            for (let i = 0; i < currentStepIndex; i++) {
                const prevStatus = currentWorkflow[i].status;
                const prevRequiredCerts = getRequiredCertsForStatus(prevStatus);
                prevRequiredCerts.forEach(cert => allRequiredCerts.add(cert));
            }

            // Check if operator has all required certs
            for (let cert of allRequiredCerts) {
                if (!operatorCerts.has(cert)) {
                    return false;
                }
            }

            return true;
        }

        // Validate all operators in a step
        function validateOperatorsInStep(operatorsInStep, requiredCerts, stepIndex) {
            if (operatorsInStep.length === 0) {
                return { isValid: true, missingCount: 0 };
            }

            let missingCount = 0;
            operatorsInStep.forEach(op => {
                if (!checkOperatorHasRequiredCerts(op, requiredCerts, stepIndex)) {
                    missingCount++;
                }
            });

            return {
                isValid: missingCount === 0,
                missingCount: missingCount,
                total: operatorsInStep.length
            };
        }

        // Toggle dropdown
        function toggleDropdown(trigger) {
            const content = trigger.nextElementSibling;
            const arrow = trigger.querySelector('.arrow');
            
            content.classList.toggle('open');
            arrow.classList.toggle('open');
        }

        // Drag and drop functionality
        let draggedElement = null;
        let draggedIndex = null;

        function addDragAndDropListeners() {
            const stepCards = document.querySelectorAll('.step-card');

            stepCards.forEach(card => {
                card.addEventListener('dragstart', handleDragStart);
                card.addEventListener('dragend', handleDragEnd);
                card.addEventListener('dragover', handleDragOver);
                card.addEventListener('drop', handleDrop);
                card.addEventListener('dragenter', handleDragEnter);
                card.addEventListener('dragleave', handleDragLeave);
            });
        }

        function handleDragStart(e) {
            draggedElement = this;
            draggedIndex = parseInt(this.dataset.index);
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleDragEnd(e) {
            this.classList.remove('dragging');
            
            // Remove drag-over class from all cards
            document.querySelectorAll('.step-card').forEach(card => {
                card.classList.remove('drag-over');
            });
        }

        function handleDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';
            return false;
        }

        function handleDragEnter(e) {
            if (this !== draggedElement) {
                this.classList.add('drag-over');
            }
        }

        function handleDragLeave(e) {
            this.classList.remove('drag-over');
        }

        function handleDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }

            const dropIndex = parseInt(this.dataset.index);

            if (draggedIndex !== dropIndex) {
                // Reorder the workflow
                const [removed] = currentWorkflow.splice(draggedIndex, 1);
                currentWorkflow.splice(dropIndex, 0, removed);

                // Re-render
                renderWorkflow();
                updateStats();
            }

            return false;
        }

        // Update statistics
        function updateStats() {
            let validSteps = 0;
            let invalidSteps = 0;

            currentWorkflow.forEach((flowStep, index) => {
                const statusName = flowStep.status;
                const operatorsInStep = operators.filter(op => 
                    op.StatusName === statusName || 
                    (op.StatusName && op.StatusName.toUpperCase() === statusName.toUpperCase())
                );

                const requiredCerts = getRequiredCertsForStatus(statusName);
                const validation = validateOperatorsInStep(operatorsInStep, requiredCerts, index);

                if (validation.isValid) {
                    validSteps++;
                } else {
                    invalidSteps++;
                }
            });

            const complianceRate = currentWorkflow.length > 0 ? 
                Math.round((validSteps / currentWorkflow.length) * 100) : 0;

            document.getElementById('totalOperators').textContent = operators.length;
            document.getElementById('validSteps').textContent = validSteps;
            document.getElementById('invalidSteps').textContent = invalidSteps;
            document.getElementById('complianceRate').textContent = `${complianceRate}%`;
        }

        // Reset to ideal flow
        function resetToIdealFlow() {
            currentWorkflow = [...idealFlow];
            renderWorkflow();
            updateStats();
        }

        // Validate all steps
        function validateAll() {
            updateStats();
            alert('Validation complete! Check the stats above for results.');
        }

        // Show issues
        function showIssues() {
            let issuesList = [];

            currentWorkflow.forEach((flowStep, index) => {
                const statusName = flowStep.status;
                const operatorsInStep = operators.filter(op => 
                    op.StatusName === statusName || 
                    (op.StatusName && op.StatusName.toUpperCase() === statusName.toUpperCase())
                );

                const requiredCerts = getRequiredCertsForStatus(statusName);
                const validation = validateOperatorsInStep(operatorsInStep, requiredCerts, index);

                if (!validation.isValid) {
                    issuesList.push(`Step ${index + 1} (${statusName}): ${validation.missingCount}/${validation.total} operators missing certifications`);
                }
            });

            if (issuesList.length === 0) {
                alert('‚úì No issues found! All operators have required certifications.');
            } else {
                alert('‚ö† Issues Found:\n\n' + issuesList.join('\n'));
            }
        }

        // Cert drag and drop
        let draggedCert = null;
        let draggedCertName = null;

        function handleCertDragStart(e, element) {
            draggedCert = element;
            draggedCertName = element.dataset.cert;
            element.classList.add('dragging-cert');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', draggedCertName);
        }

        function handleCertDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';
            return false;
        }

        function handleCertDrop(e, dropZone) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            e.preventDefault();

            const certName = e.dataTransfer.getData('text/plain');
            const targetStatus = dropZone.dataset.status;
            
            if (draggedCert && certName) {
                // Remove from original location
                const sourceStatus = draggedCert.closest('.cert-list').dataset.status;
                
                // Add to new location
                addCertToStatus(targetStatus, certName);
                
                // Remove from old location if different
                if (sourceStatus !== targetStatus) {
                    removeCertFromStatus(sourceStatus, certName);
                }
                
                draggedCert.classList.remove('dragging-cert');
                draggedCert = null;
                draggedCertName = null;
                
                renderWorkflow();
                markUnsaved();
            }

            return false;
        }

        // Add certification to a status
        function addCert(statusName, stepIndex) {
            const input = document.getElementById(`newCert_${stepIndex}`);
            const certName = input.value.trim();
            
            if (!certName) {
                alert('Please enter a certification name');
                return;
            }
            
            addCertToStatus(statusName, certName);
            input.value = '';
            renderWorkflow();
            markUnsaved();
        }

        function addCertToStatus(statusName, certName) {
            console.log(`‚ûï adding cert '${certName}' to status '${statusName}'`);

            // 1. Update legacy certRequirements
            const statusData = certRequirements[statusName] || certRequirements[statusName.toUpperCase()];
            if (statusData) {
                const divisions = statusData.divisions || {};
                Object.values(divisions).forEach(divData => {
                    let required = divData.required || [];
                    // Remove any duplicates (normalize by name)
                    required = required.filter((c, idx, arr) =>
                        arr.findIndex(x => normalizeCertName(x.cert) === normalizeCertName(c.cert)) === idx
                    );
                    const exists = required.some(c => normalizeCertName(c.cert) === normalizeCertName(certName));
                    if (!exists) {
                        required.push({
                            cert: certName,
                            count: divData.total_operators || 0,
                            total: divData.total_operators || 0,
                            percentage: 100.0
                        });
                    }
                    // Always assign deduped array back
                    divData.required = required;
                });
            } else {
                console.warn('Status not found in certRequirements:', statusName);
            }

            // 2. Update certTypes (for dynamic rendering)
            let addedCount = 0;
            Object.values(pizzaStatusRequirements).forEach(pizzaStatus => {
                const mappings = pizzaStatus.status_mappings || [];
                
                // Find all mappings for this status
                mappings.filter(m => m.status === statusName).forEach(mapping => {
                    // Check if already exists in certTypes
                    const exists = certTypes.some(ct => 
                        ct.PizzaStatusID === pizzaStatus.pizza_status_id && 
                        normalizeCertName(ct.Certification) === normalizeCertName(certName) &&
                        (ct.DivisionID === mapping.division || ct.DivisionID === null) // Handle simplistic matching
                    );
                    
                    if (!exists) {
                        certTypes.push({
                            Certification: certName,
                            PizzaStatusID: pizzaStatus.pizza_status_id,
                            DivisionID: mapping.division,
                            CertificationType: 'Added in Session',
                            CertificationID: 'TEMP-' + Math.random().toString(36).substr(2, 9)
                        });
                        addedCount++;
                    }
                });
            });
            console.log(`   ‚úÖ Added to ${addedCount} mapped configurations in certTypes`);
        }

        // Remove certification
        function removeCert(e, statusName, certName) {
            e.stopPropagation();
            
            if (confirm(`Remove "${certName}" from ${statusName}?`)) {
                removeCertFromStatus(statusName, certName);
                renderWorkflow();
                markUnsaved();
            }
        }

        function removeCertFromStatus(statusName, certName) {
            const statusData = certRequirements[statusName] || certRequirements[statusName.toUpperCase()];
            if (!statusData) return;

            const divisions = statusData.divisions || {};
            
            // Remove from all divisions
            Object.values(divisions).forEach(divData => {
                if (divData.required) {
                    divData.required = divData.required.filter(c => c.cert !== certName);
                }
            });

            // ALSO UPDATE CertTypes MEMORY: Linkage removal
            // 1. Find the PizzaStatusID associated with this lifecycle status
            // (We iterate over pizzaStatusRequirements to see which PizzaStatus maps to this lifecycle status)
            const pizzaStatusIds = new Set();
            Object.values(pizzaStatusRequirements).forEach(pizzaStatus => {
                const mappings = pizzaStatus.status_mappings || [];
                mappings.filter(m => m.status === statusName).forEach(mapping => {
                    // If we are filtering by division (mainDivisionFilter), only check that division
                    if (mainDivisionFilter !== 'ALL' && mapping.division !== mainDivisionFilter) {
                         return; // Skip mismatching divisions
                    }
                    pizzaStatusIds.add(pizzaStatus.pizza_status_id);
                });
            });

            // 2. Find matching CertTypes and set PizzaStatusID to null
            let updatedCount = 0;
            certTypes.forEach(ct => {
                if (normalizeCertName(ct.Certification) === normalizeCertName(certName)) {
                     // Check if this cert belongs to one of the PizzaStatuses we are removing from
                     if (pizzaStatusIds.has(ct.PizzaStatusID)) {
                         
                         // Double check division filter logic
                         // If user is filtering "11 - Division", we should only unlink certs for division 11
                         // If mainDivisionFilter is ALL, we unlink ALL certs matching that status
                         const matchesDivision = (mainDivisionFilter === 'ALL') || 
                                                 (ct.DivisionID && ct.DivisionID.includes(mainDivisionFilter.replace(' - ', '-').split('-')[0]));
                         
                         if (matchesDivision) {
                             ct.PizzaStatusID = null; // Unlink it!
                             updatedCount++;
                         }
                     }
                }
            });
            console.log(`   ‚úÇÔ∏è Unlinked ${updatedCount} entries in CertTypes (PizzaStatusID = null)`);
        }

        // Delete entire status from a division
        function deleteStatus(statusName, divisionId) {
            if (!confirm(`‚ö†Ô∏è Are you sure you want to remove "${statusName}" from Division ${divisionId}?\n\nThis will:\n1. Mark this status as deleted for this division\n2. Shift all subsequent statuses UP one step`)) {
                return;
            }

            console.log(`üóëÔ∏è Deleting status ${statusName} for division ${divisionId}`);

            // 1. Find the StatusType record
            const statusRecord = statusTypes.find(st => 
                st.Status === statusName && 
                st.DivisionID === divisionId
            );

            if (!statusRecord) {
                alert(`Error: Could not find StatusType record for ${statusName} in ${divisionId}`);
                return;
            }

            // 2. Mark as deleted
            statusRecord.isDeleted = true;
            statusRecord.IsDelete = true; // Handle potential schema inconsistencies
            const deletedOrderId = parseInt(statusRecord.OrderID);
            console.log(`   - Marked ID ${statusRecord.Id} as deleted (Order: ${deletedOrderId})`);

            // 3. Find other statuses in this division and shift OrderID
            let shiftedCount = 0;
            statusTypes.forEach(st => {
                if (st.DivisionID === divisionId && 
                    !st.isDeleted && 
                    !st.IsDelete && 
                    st.Status !== statusName) {
                    
                    const currentOrder = parseInt(st.OrderID);
                    if (currentOrder > deletedOrderId) {
                        st.OrderID = (currentOrder - 1).toString();
                        shiftedCount++;
                    }
                }
            });
            console.log(`   - Shifted ${shiftedCount} subsequent statuses up`);

            // 4. Force UI refresh
            markUnsaved();
            
            // Re-infer workflow from new status data? 
            // Currently idealFlow is static, so we might need a page reload to see effect fully, 
            // or we manually remove it from current view.
            alert('Status marked for removal. Please click "Save Changes" to apply.');
            
            // Reload page suggestion?
            // For now, let's just save.
        }

        // Mark as having unsaved changes
        function markUnsaved() {
            hasUnsavedChanges = true;
            document.getElementById('unsavedIndicator').style.display = 'block';
            document.getElementById('saveBtn').style.display = 'inline-block';
        }

        // Save changes - exports to pay_PizzaStatusRequirements.json format
        async function saveChanges() {

            if (!hasUnsavedChanges) {
                alert('No changes to save');
                return;
            }

            // --- SQL DIFF GENERATOR ---
            function escapeSqlString(str) {
                return String(str ?? '').replace(/'/g, "''");
            }

            function generateStatusSqlDiff(oldArr, newArr) {
                let sql = '';
                const oldMap = {};
                oldArr.forEach(row => {
                    if (row.Status && row.DivisionID) {
                        oldMap[row.Status + '||' + row.DivisionID] = row;
                    }
                });
                const newMap = {};
                newArr.forEach(row => {
                    if (row.Status && row.DivisionID) {
                        newMap[row.Status + '||' + row.DivisionID] = row;
                    }
                });
                // Detect removed
                for (const key in oldMap) {
                    if (!newMap[key]) {
                        const row = oldMap[key];
                        sql += `DELETE FROM pay_StatusTypes WHERE Status = '${escapeSqlString(row.Status)}' AND DivisionID = '${escapeSqlString(row.DivisionID)}';\n`;
                    }
                }
                // Detect added
                for (const key in newMap) {
                    if (!oldMap[key]) {
                        const row = newMap[key];
                        sql += `INSERT INTO pay_StatusTypes (Status, DivisionID, OrderID, PizzaStatusID, Description, isDeleted) VALUES ('${escapeSqlString(row.Status)}', '${escapeSqlString(row.DivisionID)}', '${escapeSqlString(row.OrderID)}', '${escapeSqlString(row.PizzaStatusID)}', '${escapeSqlString(row.Description)}', '${row.isDeleted ? 1 : 0}');\n`;
                    }
                }
                // Detect updates
                for (const key in newMap) {
                    if (oldMap[key]) {
                        const oldRow = oldMap[key];
                        const newRow = newMap[key];
                        // Compare all relevant fields
                        const fields = ['OrderID','PizzaStatusID','Description','isDeleted'];
                        let updates = [];
                        fields.forEach(f => {
                            if ((oldRow[f]||'') != (newRow[f]||'')) {
                                let val = newRow[f];
                                if (f === 'isDeleted') val = newRow[f] ? 1 : 0;
                                updates.push(`${f} = '${escapeSqlString(val)}'`);
                            }
                        });
                        if (updates.length > 0) {
                            sql += `UPDATE pay_StatusTypes SET ${updates.join(', ')} WHERE Status = '${escapeSqlString(newRow.Status)}' AND DivisionID = '${escapeSqlString(newRow.DivisionID)}';\n`;
                        }
                    }
                }
                return sql;
            }

            function generateCertSqlDiff(oldReq, newReq) {
                let sql = '';
                // For each status/division, compare certs
                for (const status in newReq) {
                    const newDivs = newReq[status].divisions || {};
                    const oldDivs = (oldReq[status] && oldReq[status].divisions) ? oldReq[status].divisions : {};
                    for (const div in newDivs) {
                        const newCerts = (newDivs[div].required || []).map(c => c.cert);
                        const oldCerts = (oldDivs[div] && oldDivs[div].required) ? oldDivs[div].required.map(c => c.cert) : [];
                        // Added certs
                        newCerts.forEach(cert => {
                            if (!oldCerts.includes(cert)) {
                                sql += `INSERT INTO pay_StatusCerts (Status, DivisionID, Certification) VALUES ('${escapeSqlString(status)}', '${escapeSqlString(div)}', '${escapeSqlString(cert)}');\n`;
                            }
                        });
                        // Removed certs
                        oldCerts.forEach(cert => {
                            if (!newCerts.includes(cert)) {
                                sql += `DELETE FROM pay_StatusCerts WHERE Status = '${escapeSqlString(status)}' AND DivisionID = '${escapeSqlString(div)}' AND Certification = '${escapeSqlString(cert)}';\n`;
                            }
                        });
                    }
                }
                return sql;
            }

            // Generate SQL for status and cert changes
            let sqlScript = '';
            if (window.originalStatusTypes && Array.isArray(window.originalStatusTypes)) {
                sqlScript += generateStatusSqlDiff(window.originalStatusTypes, statusTypes);
            }
            if (window.originalCertRequirements && typeof window.originalCertRequirements === 'object') {
                sqlScript += generateCertSqlDiff(window.originalCertRequirements, certRequirements);
            }

            if (sqlScript) {
                const sqlBlob = new Blob([sqlScript], { type: 'text/sql' });
                const sqlUrl = URL.createObjectURL(sqlBlob);
                const a = document.createElement('a');
                a.href = sqlUrl;
                a.download = 'workflow_changes.sql';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(sqlUrl);
            }

            // Convert current requirements back to pizza status format
            const pizzaStatusFormat = convertToPizzaStatusFormat(certRequirements);
            
            // Create the JSON blob
            const jsonData = JSON.stringify(pizzaStatusFormat, null, 2);
            const blob = new Blob([jsonData], { type: 'application/json' });

            // ---------------------------------------------------------
            // 1. Try Automatic Server Save (using tools/custom_server.py)
            // ---------------------------------------------------------
            try {
                // SAVE PIZZA NEEDS
                const responsePizza = await fetch('/save-requirements', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: jsonData
                });

                // SAVE CERT TYPES (New requirement)
                // Clean up CertTypes before saving (remove temp fields)
                const cleanCertTypes = certTypes.map(ct => {
                    const clean = {...ct};
                    // Keep CertificationType if it was added, but remove temp ID prefix if we want 
                    // Actually, let's keep it as is, but maybe remove "added in session" marker if we want to persist it cleanly
                    return clean;
                });

                const responseCertTypes = await fetch('/save-cert-types', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(cleanCertTypes, null, 4)
                });

                // SAVE STATUS TYPES (New)
                const responseStatusTypes = await fetch('/save-status-types', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(statusTypes, null, 4)
                });

                if (responsePizza.ok && responseCertTypes.ok && responseStatusTypes.ok) {
                    const resultPizza = await responsePizza.json();
                    const resultCert = await responseCertTypes.json();
                    const resultStatus = await responseStatusTypes.json();
                    
                    // Success!
                    hasUnsavedChanges = false;
                    document.getElementById('unsavedIndicator').style.display = 'none';
                    document.getElementById('saveBtn').style.display = 'none';
                    
                    // Update original data reference
                    originalCertRequirements = JSON.parse(JSON.stringify(certRequirements));
                    
                    alert('‚úì Saved Requirements: ' + resultPizza.message + '\n‚úì Saved CertTypes: ' + resultCert.message + '\n‚úì Saved StatusTypes: ' + resultStatus.message);
                    return; // Stop here
                } else {
                    console.error('Server save error', responsePizza.status, responseCertTypes.status, responseStatusTypes.status);
                    alert('Partial save failure. Check console.');
                }
            } catch (err) {
                console.log('Server-side save not available or failed:', err);
                console.log('Falling back to local file methods...');
            }

            // ---------------------------------------------------------
            // 2. Fallback: File System Access API or Download
            // ---------------------------------------------------------
            
            // Try to use File System Access API if available (Chrome/Edge)
            if ('showSaveFilePicker' in window) {
                try {
                    const handle = await window.showSaveFilePicker({
                        suggestedName: 'pay_PizzaStatusRequirements.json',
                        types: [{
                            description: 'JSON Files',
                            accept: { 'application/json': ['.json'] }
                        }]
                    });
                    
                    const writable = await handle.createWritable();
                    await writable.write(blob);
                    await writable.close();
                    
                    hasUnsavedChanges = false;
                    document.getElementById('unsavedIndicator').style.display = 'none';
                    document.getElementById('saveBtn').style.display = 'none';
                    
                    // Update original data
                    originalCertRequirements = JSON.parse(JSON.stringify(certRequirements));
                    
                    alert('‚úì Changes saved successfully!\n\nThe file has been saved to data/pay_PizzaStatusRequirements.json.\nPlease refresh the page to see the changes reflected.');
                } catch (err) {
                    if (err.name !== 'AbortError') {
                        console.error('Error saving file:', err);
                        // Fallback to download
                        downloadJSON(blob, 'pay_PizzaStatusRequirements.json');
                    }
                }
            } else {
                // Fallback: download the file
                downloadJSON(blob, 'pay_PizzaStatusRequirements.json');
            }
        }

        function downloadJSON(blob, filename = 'pay_PizzaStatusRequirements.json') {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            alert('‚úì Changes exported!\n\nThe file has been downloaded as pay_PizzaStatusRequirements.json.\nPlease replace the existing file in the data/ directory and refresh the page.');
            
            hasUnsavedChanges = false;
            document.getElementById('unsavedIndicator').style.display = 'none';
            document.getElementById('saveBtn').style.display = 'none';
            
            // Update original data
            originalCertRequirements = JSON.parse(JSON.stringify(certRequirements));
        }

        // ===== CONTROL CENTER FEATURES =====

        // Global search
        function handleGlobalSearch() {
            const query = document.getElementById('globalSearch').value.trim();
            searchQuery = query.toLowerCase();
            const clearBtn = document.querySelector('.clear-search');
            clearBtn.style.display = query ? 'block' : 'none';
            renderWorkflow();
        }

        function clearGlobalSearch() {
            document.getElementById('globalSearch').value = '';
            searchQuery = '';
            document.querySelector('.clear-search').style.display = 'none';
            renderWorkflow();
        }

        // Filter controls
        function setFilter(filterType) {
            currentFilter = filterType;
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.filter === filterType);
            });
            renderWorkflow();
        }

        // Populate main division filter dropdown
        function populateMainDivisionFilter() {
            const filterSelect = document.getElementById('mainDivisionFilter');
            if (!filterSelect) return;
            
            const divisions = new Set();
            operators.forEach(op => {
                if (op.DivisionID) {
                    divisions.add(op.DivisionID);
                }
            });
            
            // Add missing divisions that should always appear
            const requiredDivisions = ['2 - IL', '5 - CA'];
            requiredDivisions.forEach(div => divisions.add(div));
            
            // Clear existing options except "All Divisions"
            filterSelect.innerHTML = '<option value="ALL">üåê All Divisions</option>';
            
            // Add individual divisions (sorted)
            Array.from(divisions).sort().forEach(div => {
                const option = document.createElement('option');
                option.value = div;
                option.textContent = div;
                filterSelect.appendChild(option);
            });
            
            console.log('‚úÖ Populated main division filter with', divisions.size, 'divisions');
        }

        // Handle main division filter change
        function handleMainDivisionFilter() {
            mainDivisionFilter = document.getElementById('mainDivisionFilter').value;
            console.log('üîÑ Division filter changed to:', mainDivisionFilter);
            renderWorkflow();
            updateStats();
        }

        // Show certification details panel
        function showCertDetails(certName, statusName) {
            const panel = document.getElementById('detailsPanel');
            const title = document.getElementById('detailsTitle');
            const subtitle = document.getElementById('detailsSubtitle');
            const content = document.getElementById('detailsContent');
            
            title.textContent = certName;
            subtitle.textContent = `Viewing details for this certification`;
            
            // Find all statuses using this cert
            const statusesUsing = [];
            Object.entries(certRequirements).forEach(([status, statusData]) => {
                const divisions = statusData.divisions || {};
                let found = false;
                Object.values(divisions).forEach(divData => {
                    ['required', 'common', 'optional'].forEach(level => {
                        if (divData[level]?.some(c => c.cert === certName)) {
                            found = true;
                        }
                    });
                });
                if (found) statusesUsing.push(status);
            });
            
            // Find operators with this cert (using normalized matching)
            const operatorsWithCert = operators.filter(op => 
                op.certifications?.some(cert => certNamesMatch(cert.CertType, certName))
            );
            
            const operatorsWithoutCert = operators.filter(op => 
                !op.certifications?.some(cert => certNamesMatch(cert.CertType, certName))
            );
            
            content.innerHTML = `
                <div class="details-section">
                    <h4>üìç Used In ${statusesUsing.length} Status${statusesUsing.length !== 1 ? 'es' : ''}</h4>
                    <div style="color: #94a3b8; font-size: 0.9rem;">
                        ${statusesUsing.join(', ') || 'None'}
                    </div>
                </div>
                
                <div class="details-section">
                    <h4>‚úÖ Operators With Cert (${operatorsWithCert.length})</h4>
                    <div class="operator-list">
                        ${operatorsWithCert.slice(0, 20).map(op => {
                            const cert = findMatchingCert(certName, op.certifications);
                            const expireDate = cert?.ExpireDate;
                            const isExpired = expireDate && new Date(expireDate) < new Date();
                            return `
                                <div class="operator-item">
                                    <span class="operator-name">${op.FullName || 'Unknown'}</span>
                                    <span class="operator-status-badge ${isExpired ? 'expired' : 'has-cert'}">
                                        ${isExpired ? '‚ö†Ô∏è Expired' : '‚úì Valid'}
                                    </span>
                                </div>
                            `;
                        }).join('')}
                        ${operatorsWithCert.length > 20 ? `<div style="color: #64748b; padding: 10px; text-align: center;">... and ${operatorsWithCert.length - 20} more</div>` : ''}
                        ${operatorsWithCert.length === 0 ? '<div style="color: #64748b; padding: 10px;">No operators have this certification</div>' : ''}
                    </div>
                </div>
                
                <div class="details-section">
                    <h4>‚ùå Operators Missing Cert (${operatorsWithoutCert.length})</h4>
                    <div class="operator-list">
                        ${operatorsWithoutCert.slice(0, 20).map(op => `
                            <div class="operator-item">
                                <span class="operator-name">${op.FullName || 'Unknown'}</span>
                                <span class="operator-status-badge missing-cert">‚úó Missing</span>
                            </div>
                        `).join('')}
                        ${operatorsWithoutCert.length > 20 ? `<div style="color: #64748b; padding: 10px; text-align: center;">... and ${operatorsWithoutCert.length - 20} more</div>` : ''}
                    </div>
                </div>
            `;
            
            panel.classList.add('open');
        }

        function closeDetailsPanel() {
            document.getElementById('detailsPanel').classList.remove('open');
        }

        // Bulk add certification to multiple statuses
        function showBulkAddModal() {
            const certName = prompt('Enter certification name to add to multiple statuses:');
            if (!certName) return;
            
            const statusesToAdd = prompt(
                `Add "${certName}" to which statuses? (comma-separated, or "all")\n\nAvailable: ${currentWorkflow.map(s => s.status).join(', ')}`
            );
            
            if (!statusesToAdd) return;
            
            let targetStatuses = [];
            if (statusesToAdd.toLowerCase() === 'all') {
                targetStatuses = currentWorkflow.map(s => s.status);
            } else {
                targetStatuses = statusesToAdd.split(',').map(s => s.trim());
            }
            
            let addedCount = 0;
            targetStatuses.forEach(statusName => {
                if (currentWorkflow.find(s => s.status === statusName)) {
                    addCertToStatus(statusName, certName);
                    addedCount++;
                }
            });
            
            alert(`Added "${certName}" to ${addedCount} status${addedCount !== 1 ? 'es' : ''}`);
            renderWorkflow();
            markUnsaved();
        }

        // Export as CSV
        function exportAsCSV() {
            let csv = 'Status,Order,Certification,Level,Operators With Cert,Total Operators,Compliance %\n';
            
            currentWorkflow.forEach(step => {
                const allCerts = getRequiredCertsForStatus(step.status);
                allCerts.forEach(cert => {
                    const withCert = operators.filter(op => 
                        op.certifications?.some(c => certNamesMatch(c.CertType, cert))
                    ).length;
                    const compliance = ((withCert / operators.length) * 100).toFixed(1);
                    
                    csv += `"${step.status}",${step.step},"${cert}",required,${withCert},${operators.length},${compliance}%\n`;
                });
            });
            
            downloadFile(`operator_lifecycle_requirements_${new Date().toISOString().split('T')[0]}.csv`, csv, 'text/csv');
            closeExportModal();
        }

        // Export compliance report
        function exportComplianceReport() {
            let report = '=== OPERATOR LIFECYCLE COMPLIANCE REPORT ===\n';
            report += `Generated: ${new Date().toLocaleString()}\n\n`;
            report += `Total Operators: ${operators.length}\n`;
            report += `Total Statuses: ${currentWorkflow.length}\n\n`;
            
            report += '=== STATUS BREAKDOWN ===\n\n';
            currentWorkflow.forEach(step => {
                const operatorsInStep = operators.filter(op => 
                    op.StatusName === step.status || 
                    (op.StatusName && op.StatusName.toUpperCase() === step.status.toUpperCase())
                );
                const allCerts = getRequiredCertsForStatus(step.status);
                const validCount = operatorsInStep.filter(op => {
                    return allCerts.every(cert => 
                        op.certifications?.some(c => certNamesMatch(c.CertType, cert))
                    );
                }).length;
                
                report += `${step.status} (Step: ${step.step})\n`;
                report += `  Required Certs: ${allCerts.length}\n`;
                report += `  Operators in Status: ${operatorsInStep.length}\n`;
                report += `  Fully Compliant: ${validCount} (${((validCount/Math.max(operatorsInStep.length, 1))*100).toFixed(1)}%)\n`;
                report += `  Certifications:\n`;
                allCerts.forEach(cert => {
                    const withCert = operatorsInStep.filter(op => 
                        op.certifications?.some(c => certNamesMatch(c.CertType, cert))
                    ).length;
                    report += `    - ${cert}: ${withCert}/${operatorsInStep.length} (${((withCert/Math.max(operatorsInStep.length,1))*100).toFixed(1)}%)\n`;
                });
                report += '\n';
            });
            
            downloadFile(`compliance_report_${new Date().toISOString().split('T')[0]}.txt`, report, 'text/plain');
            closeExportModal();
        }

        // Export bottleneck analysis
        function exportBottleneckAnalysis() {
            let report = '=== OPERATOR LIFECYCLE BOTTLENECK ANALYSIS ===\n';
            report += `Generated: ${new Date().toISOString()}\n\n`;
            
            // Find statuses with lowest compliance
            const statusCompliance = currentWorkflow.map(step => {
                const operatorsInStep = operators.filter(op => 
                    op.StatusName === step.status || 
                    (op.StatusName && op.StatusName.toUpperCase() === step.status.toUpperCase())
                );
                const allCerts = getRequiredCertsForStatus(step.status);
                const validCount = operatorsInStep.filter(op => {
                    return allCerts.every(cert => 
                        op.certifications?.some(c => certNamesMatch(c.CertType, cert))
                    );
                }).length;
                return {
                    status: step.status,
                    compliance: (validCount / Math.max(operatorsInStep.length, 1)) * 100,
                    operatorCount: operatorsInStep.length,
                    certCount: allCerts.length
                };
            }).sort((a, b) => a.compliance - b.compliance);
            
            report += '=== TOP 5 BOTTLENECK STATUSES ===\n\n';
            statusCompliance.slice(0, 5).forEach((status, idx) => {
                report += `${idx + 1}. ${status.status}\n`;
                report += `   Compliance: ${status.compliance.toFixed(1)}%\n`;
                report += `   Operators: ${status.operatorCount}\n`;
                report += `   Required Certs: ${status.certCount}\n\n`;
            });
            
            // Find most problematic certs
            const certCompliance = {};
            currentWorkflow.forEach(step => {
                const allCerts = getRequiredCertsForStatus(step.status);
                const operatorsInStep = operators.filter(op => 
                    op.StatusName === step.status || 
                    (op.StatusName && op.StatusName.toUpperCase() === step.status.toUpperCase())
                );
                allCerts.forEach(cert => {
                    if (!certCompliance[cert]) {
                        certCompliance[cert] = { total: 0, with: 0, statuses: [] };
                    }
                    certCompliance[cert].total += operatorsInStep.length;
                    certCompliance[cert].with += operatorsInStep.filter(op => 
                        op.certifications?.some(c => certNamesMatch(c.CertType, cert))
                    ).length;
                    certCompliance[cert].statuses.push(step.status);
                });
            });
            
            const certArray = Object.entries(certCompliance).map(([cert, data]) => ({
                cert,
                compliance: (data.with / Math.max(data.total, 1)) * 100,
                statuses: data.statuses.length
            })).sort((a, b) => a.compliance - b.compliance);
            
            report += '\n=== TOP 10 PROBLEMATIC CERTIFICATIONS ===\n\n';
            certArray.slice(0, 10).forEach((cert, idx) => {
                report += `${idx + 1}. ${cert.cert}\n`;
                report += `   Compliance: ${cert.compliance.toFixed(1)}%\n`;
                report += `   Used in ${cert.statuses} status${cert.statuses !== 1 ? 'es' : ''}\n\n`;
            });
            
            downloadFile(`bottleneck_analysis_${new Date().toISOString().split('T')[0]}.txt`, report, 'text/plain');
            closeExportModal();
        }

        // Export JSON backup
        function exportJSON() {
            const backup = {
                exportDate: new Date().toISOString(),
                workflow: currentWorkflow,
                requirements: certRequirements,
                operators: operators,
                stats: {
                    totalOperators: operators.length,
                    totalStatuses: currentWorkflow.length,
                    totalCertifications: allExistingCerts.length
                }
            };
            
            downloadFile(
                `lifecycle_backup_${new Date().toISOString().split('T')[0]}.json`,
                JSON.stringify(backup, null, 2),
                'application/json'
            );
            closeExportModal();
        }

        // Show certification analytics
        function showCertAnalytics() {
            const certStats = {};
            
            currentWorkflow.forEach(step => {
                const allCerts = getRequiredCertsForStatus(step.status);
                const operatorsInStep = operators.filter(op => 
                    op.StatusName === step.status || 
                    (op.StatusName && op.StatusName.toUpperCase() === step.status.toUpperCase())
                );
                allCerts.forEach(cert => {
                    if (!certStats[cert]) {
                        certStats[cert] = {
                            statuses: [],
                            totalRequired: 0,
                            totalWith: 0
                        };
                    }
                    certStats[cert].statuses.push(step.status);
                    certStats[cert].totalRequired += operatorsInStep.length;
                    certStats[cert].totalWith += operatorsInStep.filter(op => 
                        op.certifications?.some(c => certNamesMatch(c.CertType, cert))
                    ).length;
                });
            });
            
            const sortedCerts = Object.entries(certStats)
                .map(([cert, data]) => ({
                    cert,
                    compliance: (data.totalWith / Math.max(data.totalRequired, 1) * 100).toFixed(1),
                    statuses: data.statuses.length,
                    totalWith: data.totalWith,
                    totalRequired: data.totalRequired
                }))
                .sort((a, b) => b.statuses - a.statuses);
            
            let report = '=== CERTIFICATION ANALYTICS ===\n\n';
            report += `Most Used Certifications:\n\n`;
            sortedCerts.slice(0, 15).forEach((cert, idx) => {
                report += `${idx + 1}. ${cert.cert}\n`;
                report += `   Used in: ${cert.statuses} statuses\n`;
                report += `   Compliance: ${cert.compliance}% (${cert.totalWith}/${cert.totalRequired})\n\n`;
            });
            
            alert(report);
        }

        // Clear all certifications
        function confirmClearAll() {
            if (confirm('‚ö†Ô∏è WARNING: This will remove ALL certifications from ALL statuses.\n\nAre you sure you want to continue?')) {
                Object.values(certRequirements).forEach(statusData => {
                    const divisions = statusData.divisions || {};
                    Object.values(divisions).forEach(divData => {
                        divData.required = [];
                        divData.common = [];
                        divData.optional = [];
                    });
                });
                renderWorkflow();
                markUnsaved();
                alert('All certifications have been cleared.');
            }
        }

        // Helper function to download files
        function downloadFile(filename, content, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function showExportModal() {
            document.getElementById('exportModal').classList.add('open');
        }

        function closeExportModal() {
            document.getElementById('exportModal').classList.remove('open');
        }

        // Show operator profile modal
        function showOperatorProfile(operatorId) {
            const operator = operators.find(op => op.ID === operatorId);
            if (!operator) {
                alert('Operator not found');
                return;
            }

            const modal = document.getElementById('operatorModal');
            const nameEl = document.getElementById('operatorModalName');
            const subtitleEl = document.getElementById('operatorModalSubtitle');
            const bodyEl = document.getElementById('operatorModalBody');

            nameEl.textContent = `${operator.FirstName} ${operator.LastName}`;
            subtitleEl.textContent = `${operator.StatusName || 'Unknown Status'} ‚Ä¢ Division ${operator.DivisionID || 'N/A'}`;

            // Get certs needed for THIS operator's division - CUMULATIVE from all previous steps
            const allCertsNeeded = new Set();
            const opDivision = operator.DivisionID || '';
            const opStatus = operator.StatusName || '';
            
            // Find operator's current step in the workflow
            const currentStepIndex = idealFlow.findIndex(s => s.status === opStatus);
            
            // Accumulate requirements from current status AND all previous statuses
            if (currentStepIndex >= 0) {
                // Get all statuses up to and including current
                const relevantStatuses = idealFlow.slice(0, currentStepIndex + 1).map(s => s.status);
                
                // Collect requirements from all these statuses for operator's division
                relevantStatuses.forEach(statusName => {
                    const statusData = certRequirements[statusName];
                    if (statusData) {
                        const divisions = statusData.divisions || {};
                        if (opDivision && divisions[opDivision]) {
                            (divisions[opDivision].required || []).forEach(cert => {
                                allCertsNeeded.add(cert.cert);
                            });
                        }
                    }
                });
            }

            // Get operator's certifications
            const operatorCerts = operator.certifications || [];
            
            // Build cert status map
            const certStatusMap = {};
            allCertsNeeded.forEach(certName => {
                const cert = findMatchingCert(certName, operatorCerts);
                if (cert) {
                    // Check if approved (Status != '0' AND has dates)
                    const isApproved = cert.Status !== '0' && (cert.IssueDate || cert.ExpireDate);
                    
                    if (!isApproved) {
                        // Not approved yet - show as missing
                        certStatusMap[certName] = {
                            status: 'missing',
                            label: 'Not Approved',
                            issueDate: cert.IssueDate,
                            expireDate: cert.ExpireDate
                        };
                    } else {
                        // Approved - check expiration
                        const expireDate = cert.ExpireDate ? new Date(cert.ExpireDate) : null;
                        const isExpired = expireDate && expireDate < new Date();
                        certStatusMap[certName] = {
                            status: isExpired ? 'expired' : 'has-cert',
                            label: isExpired ? 'Expired' : 'Valid',
                            issueDate: cert.IssueDate,
                            expireDate: cert.ExpireDate
                        };
                    }
                } else {
                    certStatusMap[certName] = {
                        status: 'missing',
                        label: 'Missing'
                    };
                }
            });

            // Count stats
            const validCount = Object.values(certStatusMap).filter(c => c.status === 'has-cert').length;
            const expiredCount = Object.values(certStatusMap).filter(c => c.status === 'expired').length;
            const missingCount = Object.values(certStatusMap).filter(c => c.status === 'missing').length;

            // Build HTML
            let html = `
                <div class="operator-info-grid">
                    <div class="operator-info-item">
                        <div class="operator-info-label">Operator ID</div>
                        <div class="operator-info-value">${operator.ID}</div>
                    </div>
                    <div class="operator-info-item">
                        <div class="operator-info-label">Status</div>
                        <div class="operator-info-value">${operator.StatusName || 'Unknown'}</div>
                    </div>
                    <div class="operator-info-item">
                        <div class="operator-info-label">Division</div>
                        <div class="operator-info-value">${operator.DivisionID || 'N/A'}</div>
                    </div>
                    <div class="operator-info-item">
                        <div class="operator-info-label">Total Certifications</div>
                        <div class="operator-info-value">${operatorCerts.length} of ${allCertsNeeded.size}</div>
                    </div>
                </div>

                <div class="cert-stats">
                    <div class="cert-stat">
                        <div class="cert-stat-value valid">${validCount}</div>
                        <div class="cert-stat-label">Valid</div>
                    </div>
                    <div class="cert-stat">
                        <div class="cert-stat-value expired">${expiredCount}</div>
                        <div class="cert-stat-label">Expired</div>
                    </div>
                    <div class="cert-stat">
                        <div class="cert-stat-value missing">${missingCount}</div>
                        <div class="cert-stat-label">Missing</div>
                    </div>
                </div>

                <h3 class="certs-section-title">All Certifications (${allCertsNeeded.size})</h3>
                <div class="cert-grid">
            `;

            // Sort certs: valid first, then expired, then missing
            const sortedCerts = Array.from(allCertsNeeded).sort((a, b) => {
                const statusOrder = { 'has-cert': 0, 'expired': 1, 'missing': 2 };
                return statusOrder[certStatusMap[a].status] - statusOrder[certStatusMap[b].status];
            });

            sortedCerts.forEach(certName => {
                const certInfo = certStatusMap[certName];
                html += `
                    <div class="cert-card ${certInfo.status}">
                        <div class="cert-card-name">${certName}</div>
                        <div class="cert-card-status">${certInfo.label}</div>
                    </div>
                `;
            });

            html += `</div>`;

            bodyEl.innerHTML = html;
            modal.classList.add('open');
        }

        function closeOperatorModal() {
            document.getElementById('operatorModal').classList.remove('open');
        }


        function handleStatusSelectChange() {
            // Auto-select corresponding Pizza Mapping if name matches
            const statusNameSelect = document.getElementById('addStatusNameSelect');
            if (!statusNameSelect) return;
            const statusName = statusNameSelect.value;
            if (!statusName) return;
            // Simple fuzzy match attempt
            const select = document.getElementById('addStatusPizzaMapping');
            if (!select) return;
            for(let i=0; i<select.options.length; i++) {
                if (select.options[i].text.toUpperCase() === statusName.toUpperCase()) {
                    select.selectedIndex = i;
                    break;
                }
            }
        }

        function confirmAddStatus() {


            try {
                console.log('[DEBUG] confirmAddStatus called');
                const divisionInput = document.getElementById('addStatusDivision');
                const statusNameInput = document.getElementById('addStatusNameSelect');
                const targetOrderInput = document.getElementById('addStatusPosition');
                const pizzaStatusInput = document.getElementById('pizzaStatusesDropdown');

                if (!divisionInput || !statusNameInput || !targetOrderInput || !pizzaStatusInput) {
                    alert('A required field is missing in the Add Status form.');
                    console.error('[AddStatus] One or more DOM elements are null');
                    return;
                }

                const division = divisionInput.value;
                const statusName = statusNameInput.value;
                const targetOrder = parseInt(targetOrderInput.value);
                const pizzaStatusId = pizzaStatusInput.value;

                if (!statusName) {
                    alert('Please select a Status Name.');
                    console.error('[AddStatus] Status Name missing');
                    return;
                }
                if (!targetOrder || isNaN(targetOrder)) {
                    alert('Please select a valid Insert Position.');
                    console.error('[AddStatus] Insert Position missing or invalid');
                    return;
                }
                if (!pizzaStatusId) {
                    alert('Please select a Pizza Status Mapping.');
                    console.error('[AddStatus] Pizza Status Mapping missing');
                    return;
                }

                console.log(`üöÄ Adding Status '${statusName}' to '${division}' at Order ${targetOrder}`);

                // 1. Shift existing orders DOWN
                let shiftedCountDown = 0;
                statusTypes.forEach(st => {
                    if (st.DivisionID === division && 
                        !(st.isDeleted === true || st.IsDelete === true) && 
                        st.Status !== statusName) { // Don't shift the one we are about to update if it exists
                        const currentOrd = parseInt(st.OrderID) || 0;
                        if (currentOrd >= targetOrder) {
                            st.OrderID = (currentOrd + 1).toString();
                            shiftedCountDown++;
                        }
                    }
                });
                console.log(`   shifted ${shiftedCountDown} subsequent statuses down`);

                // 2. Find or Create StatusType Record
                let stRecord = statusTypes.find(st => st.DivisionID === division && st.Status === statusName);
                let wasDeleted = false;
                if (stRecord) {
                    // If status was deleted, mark as restored and always update all key fields
                    wasDeleted = (stRecord.isDeleted === true || stRecord.IsDelete === true || String(stRecord.isDeleted) === 'true');
                    stRecord.isDeleted = false;
                    stRecord.IsDelete = false;
                    stRecord.OrderID = targetOrder.toString();
                    stRecord.PizzaStatusID = pizzaStatusId;
                    // Defensive: update Description and RecordAt if missing
                    if (!stRecord.Description) stRecord.Description = statusName;
                    if (!stRecord.RecordAt) stRecord.RecordAt = new Date().toISOString();
                } else {
                    stRecord = {
                        Id: crypto.randomUUID ? crypto.randomUUID() : 'NEW-' + Math.random().toString(36).substr(2,9),
                        Status: statusName,
                        DivisionID: division,
                        OrderID: targetOrder.toString(),
                        isDeleted: false,
                        IsDelete: false,
                        PizzaStatusID: pizzaStatusId,
                        Description: statusName,
                        RecordAt: new Date().toISOString(),
                        __IMTINDEX__: 0
                    };
                    statusTypes.push(stRecord);
                }

                // 3. Update Pizza Status Mapping
                const pizzaReq = Object.values(pizzaStatusRequirements).find(p => p.pizza_status_id === pizzaStatusId);
                if (pizzaReq) {
                    if (!pizzaReq.status_mappings) pizzaReq.status_mappings = [];
                    // Remove existing mapping for this division to avoid dupes
                    pizzaReq.status_mappings = pizzaReq.status_mappings.filter(m => m.division !== division);
                    // Add new mapping
                    pizzaReq.status_mappings.push({
                        division: division,
                        status: statusName,
                        order: targetOrder.toString()
                    });
                    console.log('   Updated PizzaStatus mapping');
                }

                // Shift OrderID for all statuses at or after the new one (except the one just added/restored)
                let shiftedCountUp = 0;
                statusTypes.forEach(st => {
                    if (st.DivisionID === division && st.Status !== statusName) {
                        const currentOrd = parseInt(st.OrderID) || 0;
                        if (currentOrd >= targetOrder) {
                            st.OrderID = (currentOrd + 1).toString();
                            shiftedCountUp++;
                        }
                    }
                });

                // Mark as unsaved so Save Changes appears
                markUnsaved();

                // Visual feedback - Inject into currentWorkflow view
                const newStepObj = {
                    step: targetOrder,
                    status: statusName,
                    statusId: stRecord.Id || stRecord.ID || null
                };

                // Remove previous occurrence if existed (e.g. at other position)
                const existIdx = currentWorkflow.findIndex(s => s.status === statusName);
                if (existIdx !== -1) {
                    currentWorkflow.splice(existIdx, 1);
                }

                // Insert at correct index
                const insertIdx = targetOrder - 1;
                currentWorkflow.splice(insertIdx, 0, newStepObj);

                // Re-number steps
                currentWorkflow.forEach((step, idx) => {
                    step.step = idx + 1;
                });

                renderWorkflow();

                let msg = `Added status "${statusName}" at Step ${targetOrder}.`;
                if (wasDeleted) {
                    msg += `\n\nNote: This status was previously deleted and has now been restored.`;
                }
                msg += `\n\nPlease click "Save Changes" to persist this to the database.`;
                alert(msg);
            } catch (err) {
                alert('An error occurred in confirmAddStatus. See console for details.');
                console.error('[AddStatus] Exception:', err);
                return;
            }
        }

        // Initialize on page load
        window.addEventListener('DOMContentLoaded', loadData);

        // Fallback: Attach Add Status button handler globally in case inline onclick fails
        document.addEventListener('click', function(e) {
            // Log all clicks for debugging
            // (Removed global Add Status button handler and alert)
        });

        // Log all clicks on elements that could trigger the Add Status modal
        document.addEventListener('click', function(e) {
            // Log all clicks for debugging
            if (e.target && e.target.closest('.bulk-btn, .add-status-btn, .btn-add-status')) {
                console.log('[DEBUG] Potential Add Status trigger clicked:', e.target);
            }
        });

    </script>


    <!-- Confirmation Modal -->
    <div id="confirmModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <span>‚ö†Ô∏è</span>
                <span>Confirm Action</span>
            </div>
            <div class="modal-body" id="confirmModalText">
                <!-- Dynamic content will be inserted here -->
            </div>
            <div class="modal-actions">
                <button class="btn btn-secondary" id="confirmNo">Cancel</button>
                <button class="btn btn-danger" id="confirmYes">Yes, Proceed</button>
            </div>
        </div>
    </div>

</body>
    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" crossorigin="anonymous"></script>
    <script>
    // Patch showAddStatusAccordion to populate fields when accordion is opened
    function showAddStatusAccordion(paramDivision) {
        const division = paramDivision || mainDivisionFilter;
        if (!division || division === 'ALL') return;
        document.getElementById('addStatusDivision').value = division;

        // 1. Populate Status Select
        const statusSelect = document.getElementById('addStatusNameSelect');
        statusSelect.innerHTML = '<option value="">-- Select Status --</option>';

        // Get all statuses for this division
        const divisionStatuses = statusTypes.filter(st => st.DivisionID === division);
        const getStName = (st) => st.Status || st.status || '';
        const divisionStatusNames = new Set(divisionStatuses.map(getStName));

        // Get other known statuses (from other divisions)
        const otherStatusNames = new Set();
        statusTypes.forEach(st => {
            const name = getStName(st);
            if (name && !divisionStatusNames.has(name)) {
                otherStatusNames.add(name);
            }
        });

        // Add division statuses first (Deleted ones marked)
        divisionStatuses.sort((a,b) => getStName(a).localeCompare(getStName(b)));
        divisionStatuses.forEach(st => {
            const name = getStName(st);
            const isDeleted = st.isDeleted === true || st.IsDelete === true || String(st.isDeleted) === 'true';
            const opt = document.createElement('option');
            opt.value = name;
            if (isDeleted) {
                opt.innerHTML = `‚ôªÔ∏è RESTORE: ${name}`;
                opt.className = 'status-option-deleted';
            } else {
                opt.innerHTML = `‚úì EXISTING: ${name}`;
                opt.disabled = true;
            }
            statusSelect.appendChild(opt);
        });

        // Add separator
        const sep = document.createElement('option');
        sep.disabled = true;
        sep.innerHTML = '--- New Statuses (from other divisions) ---';
        statusSelect.appendChild(sep);

        // Add other statuses
        Array.from(otherStatusNames).sort().forEach(name => {
            const opt = document.createElement('option');
            opt.value = name;
            opt.innerHTML = `‚ûï NEW: ${name}`;
            statusSelect.appendChild(opt);
        });

        // 2. Populate Position Select
        const posSelect = document.getElementById('addStatusPosition');
        posSelect.innerHTML = '';
        const currentActiveStatuses = statusTypes.filter(st =>
            st.DivisionID === division &&
            !(st.isDeleted === true || st.IsDelete === true || String(st.isDeleted) === 'true')
        ).sort((a, b) => {
            const aOrd = parseInt(a.OrderID) || 999;
            const bOrd = parseInt(b.OrderID) || 999;
            return aOrd - bOrd;
        });
        // Option: Start
        const startOpt = document.createElement('option');
        startOpt.value = "1";
        startOpt.innerHTML = "Start (Step 1)";
        posSelect.appendChild(startOpt);
        currentActiveStatuses.forEach((st, idx) => {
            const currentOrder = parseInt(st.OrderID) || (idx + 1);
            const nextOrder = currentOrder + 1;
            const opt = document.createElement('option');
            opt.value = nextOrder.toString();
            opt.innerHTML = `After ${getStName(st)} (Step ${nextOrder})`;
            posSelect.appendChild(opt);
        });
        if (currentActiveStatuses.length > 0) {
            posSelect.value = (parseInt(currentActiveStatuses[currentActiveStatuses.length - 1].OrderID) + 1).toString();
        }
    }
    // Attach handler for Add Status confirm button (Accordion)
    document.addEventListener('DOMContentLoaded', function() {
        // Remove any old Add Status button (if present)
        const oldBtn = document.querySelector('.add-status-btn, .btn-add-status');
        if (oldBtn) oldBtn.style.display = 'none';

        const addStatusBtn = document.getElementById('addStatusConfirmBtn');
        if (addStatusBtn) {
            addStatusBtn.addEventListener('click', function(e) {
                e.preventDefault();
                confirmAddStatus();
            });
        }
        // Auto-populate when accordion is opened
        const addStatusCollapse = document.getElementById('addStatusCollapse');
        if (addStatusCollapse) {
            addStatusCollapse.addEventListener('show.bs.collapse', function() {
                showAddStatusAccordion();
            });
        }
    });

    // Populate new PizzaStatuses dropdown with all statuses from pay_PizzaStatuses.json
    function populateAllPizzaStatusesDropdown() {
        const pizzaSelect = document.getElementById('pizzaStatusesDropdown');
        if (!pizzaSelect) return;
        pizzaSelect.innerHTML = '<option value="">-- Select Pizza Status --</option>';
        fetch('../data/pay_PizzaStatuses.json')
            .then(res => res.json())
            .then(pizza_statuses => {
                pizza_statuses.filter(p => {
                    const isOperator = p.IsOperator === true;
                    const isProvider = p.IsProvider === true || p.IsProvider === 1 || p.IsProvider === '1';
                    return isOperator && (!isProvider);
                }).forEach(p => {
                    const opt = document.createElement('option');
                    opt.value = p.ID;
                    opt.innerHTML = p.Status;
                    opt.title = p.Description || '';
                    pizzaSelect.appendChild(opt);
                });
            });
    }
    window.addEventListener('DOMContentLoaded', populateAllPizzaStatusesDropdown);
    </script>
</html>
